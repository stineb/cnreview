---
title: "CO2 effects on litter production"
author: "Beni Stocker"
date: "`r Sys.Date()`"
output:
  html_document:
    #theme: paper
    toc: true
    toc_float: true
    toc_depth: 2
# output:
#   pdf_document:
#     toc: true
#     toc_depth: 2
header-includes:
   - \usepackage{amsmath}
# bibliography: bibliography.bib
---

```{r, warning=FALSE}
library(readr)
library(dplyr)
library(metafor)   # see ?dat.curtis1998 for an example with CO2 manipulation data
library(ggplot2)
library(stringr)
```


*Data Screening is identical to code in `dataanalysis.Rmd`*

# Data screening

For a first data screening want to do the following:

1. Get data from eCO2 experiments
2. Data availability per experiment
3. Data availability per variable
4. Long versus wide issue

Let's check first if the data is ready to use for these steps.

But before we start:

- Some variable names end with an underscore (`ANPP_`, `Asat_`, `SLA_`, `coarse_root_biomass_`, `LMA_`, `soil_NH4+_`, `N_uptake_`). Needed to delete that manually.
- Replaced lots of superscripted numbers (actually appeared as superscript when opening the CSV file in my text editor) with plain number (e.g., `m2`)
- Replaced units given like `g_m-2` with `g/m2`, or `kg_ha-1` with `kg/ha`, or `g/m2*yr` with `g/m2/yr` (assuming that's correct if that's the way it would be entered in R), `_g/m2` with `g/m2`, `cm2/m2*d` with `cm2/m2/d`, ... I'll leave it with that for now.
- Replaced `Vcmax_normalized_to_25°C` with `Vcmax25`, and `Jmax_normalized_to_25°C` with `Jmax25` (problematic degree sign)
- Removed weird symbol in units, e.g., `‘mol_CO2/m2/s` to `mol_CO2/m2/s`
- Removed line break in date string

**All that is saved as a new file `NewData_wide_CORRECTED2.csv`**

Load the corrected file, which is based on the one Kevin sent on 1.3.2019.
```{r, warning=FALSE}
df <- read_csv("~/data/gcme/data_received_190325/NewData_wide_CORRECTED2.csv") %>%
  
  # something is wrong in columns ambient_Sd, ambient_Se, elevated...
  mutate( ambient_Sd  = as.numeric(ambient_Sd),  ambient_Se  = as.numeric(ambient_Se), 
          elevated_Sd = as.numeric(elevated_Sd), elevated_Se = as.numeric(elevated_Se) )
  
  # XXX testing
  # filter(exp_nam == "SwissFACE_lolium2" & Data_type == "aboveground_biomass")
  # filter(exp_nam == "SwissFACE_trifolium2" & Data_type == "aboveground_biomass")

# save experiments names
df_experiments <- df %>% select(exp_nam, prev_name) %>% distinct()
```

## 0. Issues

### Sampling date

This is not read in correctly. Either continue doing manual edits (open CSV in editor and check whether it's in a consistent format, at least within experiments), or do something clever if sampling date formats are at least consistent within experiments: e.g., reading the table experiment per experiment (making use of automatic interpretation of the sampling date format by read_csv()) and then stack all experiments' data together again.

### Duplicate rows

Some rows are simply duplicates. This is dangerous.
```{r}
keyvars <- c("exp_nam", "factors", "treatment", "Data_type", "Unit", "Sampling_date", "Start_Year", "Year", "n_plots")
valuevars <-  c("ambient", "ambient_Se", "ambient_Sd", "elevated", "elevated_Se", "elevated_Sd")

df %>% 
  filter(exp_nam == "SwissFACE_trifolium2" & Data_type == "aboveground_biomass") %>% 
  filter(treatment=="cf") %>% 
  select(one_of(keyvars, valuevars)) %>% 
  print()
```

This may be remediated automatically by using only columns that are distinct w.r.t. `valuevars` and `keyvars` (basically all columns in original data, except `ALIAS`).
```{r}
print(nrow(df))
df <- df %>% 
  distinct_at(vars(one_of(keyvars, valuevars))) %>%
  mutate( id=1:n() )   # create new ID key (before this was 'ALIAS')
print(nrow(df))

df %>% 
  filter(exp_nam == "SwissFACE_trifolium2" & Data_type == "aboveground_biomass") %>% 
  filter(treatment=="cf") %>% 
  select(one_of(keyvars, valuevars)) %>% 
  print()
```

Still problems?
```{r}
df %>% 
  filter(exp_nam == "SwissFACE_lolium2" & Data_type == "belowground_biomass") %>% 
  filter(treatment=="cf", Year==6) %>% 
  select(one_of(keyvars, valuevars)) %>% 
  print()
```
Yes. In this case, the problem has to do with `Sampling_date`. I suspect that the problem with `Sampling_date` is that it was manually entered and consistency may be respected within experiments (and variables?), but not across variables. When read into R with `readr::read_csv()`, different formats are interpreted always with the same function. A possible solution to this is to read data separately for each experiment and variable and stack them together again (`bind_rows()`).

**TODO:**

- First, do some manual cleaning of `Sampling_date` as far as possible and reasonable. Then, develop a separate read-in by experiments and variables, stack data again, and write the combined data to file.

### Distinct ambients

The way the wide format is designed, the ambient values should be the same for different rows corresponding to different treatments (for a given experiment, variable, and sampling year). This is not always the case. It might be that these are actually different data from multiple samplings. However, this is not identifiable, but should be. An example:
```{r}
df %>% 
  filter(exp_nam == "SwissFACE_lolium2" & Data_type == "Rh" ) %>% 
  print()
```

**TODO:**

- I haven't figured out how to do a bulk-check on this and resolve this. It doesn't affect too many entries. Hence, it might have to be cleaned by hand.


## 4. Long versus wide


### An example conversion

How to perform a conversion of our current wide format to a long format? Let's do it for one example. An example for how the wide format is implemented in the current dataset:
```{r}
df_wide <- df %>% 
  filter(exp_nam=="SwissFACE_lolium2", Data_type=="aboveground_biomass") %>%
  select(exp_nam, factors, treatment, Data_type) %>% 
  distinct() %>%
  mutate( id=1:nrow(.),
          ambient=rep("A", 3), elevated=c("B", "C", "D"),
          ambient_Sd=rep("sdA", 3), elevated_Sd=c("sdB", "sdC", "sdD"),
          ambient_Se=rep("seA", 3), elevated_Se=c("seB", "seC", "seD")) %>%
  print()
```

To convert this to a long format, first get all available factors and create a vector. The available factors are:
```{r}
df %>% 
  filter(!(factors %in% c("x","x99"))) %>% 
  select(factors) %>% 
  unique() %>% 
  unlist() %>% 
  unname() %>% 
  print()
```

Create a vector with all single factors
```{r}
factors_avl <- df %>%
  filter(!(factors %in% c("x","x99"))) %>%      # Something weird with this
  select(factors) %>% 
  unique() %>% 
  mutate( factors_sep = strsplit(factors, NULL) ) %>% 
  select(factors_sep) %>% 
  unlist() %>% 
  unname() %>% 
  unique() %>% 
  print()
```

Convert from wide to long, adding columns for all factors for which we have ambient and elevated levels' data.
```{r warning=FALSE}
source("R/wide_to_long_gcme.R")

# run it
keyvars <- c("id", "exp_nam", "factors", "level", "treatment", "Data_type")
valuevars <-  c("ambient", "ambient_Se", "ambient_Sd", "elevated", "elevated_Se", "elevated_Sd")

df_long_example <- df_wide %>%
  select(one_of(keyvars, valuevars)) %>%
  wide_to_long_gcme( keyvars ) %>%
  print()
```


### Converting the entire table

Let's apply this to the full data frame. First, keep only some of the columns:
```{r warning=FALSE, eval=FALSE}
keyvars <- c("id", "exp_nam", "factors", "treatment", "level", "Data_type", "Unit", "Start_Year", "Year",  "n_plots")
valuevars <-  c("ambient", "ambient_Se", "ambient_Sd", "elevated", "elevated_Se", "elevated_Sd")

df_long <- df %>% 
  select(one_of(keyvars, valuevars)) %>%
  wide_to_long_gcme(keyvars) %>% 
  write_csv(path="~/data/gcme/data_received_190325/NewData_LONG.csv")
```

Thus, we have a long-format data table, that has *less* than twice as many rows as the original table, because the "absolute ambient" is no longer repeated:
```{r eval=FALSE}
print(nrow(df)*2)
nrow(df_long)
```


#### Test

Test, whether the conversion was doing alright.
```{r}
check_cf <- function(df_wide, df_long, verbose=FALSE){

  ## check cf experiments
  df_cf <- df_wide %>% filter(treatment %in% c("f","c","cf","fc"))

  out <- tibble()

  all_exp <- df_cf$exp_nam %>% unique

  for (iexp in all_exp){

    df_sub <- df_cf %>% filter(exp_nam==iexp)

    all_var <- df_sub$Data_type %>% unique

    for (ivar in all_var){

      df_subsub <- df_sub %>% filter(Data_type==ivar)

      all_var_unit <- df_subsub$Unit %>% unique

      for (iunit in all_var_unit){

        df_subsubsub <- df_subsub %>% filter(Unit==iunit)

        # elevated-f treatment
        correct_f <- df_subsubsub %>% 
          filter(treatment=="f") %>% 
          select(exp_nam, Data_type, Unit, Year, mean=elevated, se=elevated_Se, sd=elevated_Sd) %>%
          all_equal( ., df_long %>% filter(f & !c & exp_nam==iexp & Data_type==ivar & Unit==iunit) %>% select(exp_nam, Data_type, Unit, Year, mean, se, sd) )

        # elevated-c treatment
        correct_c <- df_subsubsub %>% 
          filter(treatment=="c") %>% 
          select(exp_nam, Data_type, Unit, Year, mean=elevated, se=elevated_Se, sd=elevated_Sd) %>%
          all_equal( ., df_long %>% filter(!f & c & exp_nam==iexp & Data_type==ivar & Unit==iunit) %>% select(exp_nam, Data_type, Unit, Year, mean, se, sd) )

        # elevated-cf treatment
        correct_cf <- df_subsubsub %>% 
          filter(treatment=="cf") %>% 
          select(exp_nam, Data_type, Unit, Year, mean=elevated, se=elevated_Se, sd=elevated_Sd) %>%
          all_equal( ., df_long %>% filter(f & c & exp_nam==iexp & Data_type==ivar & Unit==iunit) %>% select(exp_nam, Data_type, Unit, Year, mean, se, sd) )

        # (absolute) control: WARNING: DUPLICATED ROWS
        correct_0 <- df_subsubsub %>% 
          distinct(exp_nam, Data_type, Unit, Year, ambient, ambient_Se, ambient_Sd, .keep_all=TRUE) %>% 
          select(exp_nam, Data_type, Unit, Year, mean=ambient, se=ambient_Se, sd=ambient_Sd) %>%
          all_equal( ., df_long %>% filter(!f & !c & exp_nam==iexp & Data_type==ivar & Unit==iunit) %>% select(exp_nam, Data_type, Unit, Year, mean, se, sd) )
        
        if (verbose){
        if (!identical(correct_0, TRUE)){
          rlang::warn(correct_0)
          print("WIDE:")
          df_subsubsub %>%
            distinct(exp_nam, Data_type, Unit, Year, ambient, ambient_Se, ambient_Sd, .keep_all=TRUE) %>%
            select(exp_nam, Data_type, Unit, Year, mean=ambient, se=ambient_Se, sd=ambient_Sd) %>%
            print()
          print("LONG:")
          df_long %>%
            filter(!f & !c & exp_nam==iexp & Data_type==ivar & Unit==iunit) %>%
            select(exp_nam, Data_type, Unit, Year, mean, se, sd) %>%
            print()
          print("---------")
        }
        }

        out <- bind_rows(out, c(factors="cf", exp_nam=iexp, Data_type=ivar, Unit=iunit, correct_0=correct_0, correct_c=correct_c, correct_f=correct_f, correct_cf=correct_cf))

      }
    }
  }

  return(out)
}
out <- check_cf( df, df_long) %>% head()
```

**Issue:**

- There are still lots of problems with identifying the ambients (see column `correct_0` in `out`). See for example:

```{r eval=FALSE}
## note row 18 is missing in wide
out <- check_cf( filter(df, exp_nam=="BioCON", Data_type=="leaf_N", Year==4), df_long, verbose = TRUE)
```

**TODO:**

- Make sure the wide-to-long conversion works fine. That is, `out` should have `TRUE` in all columns. 


### Converting back with a twist

In the original data, `ambient` was the "absolute ambient". For example in the `cf` treatment, `ambient` was no treatment at all (control), and `elevated` was `c` $\times$ `f`. We may re-design a wide version of the table and allow flexibility in what treatments are compared to each other, i.e., what `ambient` means. I would argue that this depends whether we are interested in a *single* effect or in interactions. In our case, we are interested primarily in the CO2 effect. Hence, in a factorial experiment `cf`, we may want to compare `c` to `0` (an "absolute ambient"), and `cf` to `f` and thus have more data available to evaluate the CO2-only effect.

Let's implement this, by converting our example back to a CO2-wide format:
```{r}
long_to_wide_gcme <- function(df_long, keyvar){

  joinvars <- names(df_long)[-which(names(df_long) %in% c("mean", "sd", "se", keyvar))]
  factors_all <- df_long %>%
    filter(!(factors %in% c("x","x99"))) %>%      # Something weird with this
    select(factors) %>% 
    unique() %>% 
    mutate( factors_sep = strsplit(factors, NULL) ) %>% 
    select(factors_sep) %>% 
    unlist() %>% 
    unname() %>% 
    unique()
  factorvars <- factors_all[-which(factors_all==keyvar)]
    
  # take all data where factor 'c' is TRUE
  df_wide <- dplyr::filter(df_long, eval(parse(text=keyvar)) ) %>% 
    
    # call this 'elevated'
    dplyr::rename(elevated=mean, elevated_sd=sd, elevated_se=se) %>% 
    
    # remove column 'c', is no longer used
    dplyr::select(-keyvar) %>% 
    
    # merge this with the corresponding row where all other factors are the same, while 'c' is FALSE
    left_join( 
      
      # take all data where factor 'c' is FALSE
      dplyr::filter(df_long, !(eval(parse(text=keyvar)))) %>% 

        # call this 'ambient'
        dplyr::rename(ambient=mean, ambient_sd=sd, ambient_se=se) %>% 

        # remove column 'c', is no longer used
        dplyr::select(-keyvar),
      
      ## merge by all other columns
      by = joinvars ) %>% 
    
    # order columns
    select( c(joinvars, ambient, elevated, ambient_se, elevated_se, ambient_sd, elevated_sd)  )

  return(df_wide)
}
```

Run it
```{r}
df_long_example %>%
  long_to_wide_gcme("c") %>%
  print()
```

The same can be done w.r.t. the fertilisation treatment, with two rows corresponding now to whether or not CO2 was elevated.
```{r}
df_long_example %>%
  long_to_wide_gcme("f") %>%
  print()
```

Let's apply this to the full data frame.
```{r eval=FALSE}
keyvars <- c("ALIAS", "exp_nam", "factors", "Data_type", "Unit", "Sampling_date", "n_plots")
valuevars <-  c("mean", "sd", "se")

df_wide_c <- df_long %>% 
  # select(one_of(keyvars, valuevars, factors_avl)) %>%
  # select(-prev_name, -TT_Nut_Detail) %>% 
  long_to_wide_gcme("c") %>% 
  write_csv(path="~/data/gcme/data_received_190325/created/NewData_WIDE_c.csv")
```

**TODO:**

- Develop a test to check the new-wide format against the long or against the original-wide table.


<!-- ## 4. Number of replicates -->

<!-- For each variable, get information on the number of replicates available for each experiment (and any other information that is needed for the meta analysis). That's simple now: -->
<!-- ```{r, warning=FALSE} -->
<!-- ## for Asat only -->
<!-- df_nreplicates_asat <- df_co2_asat %>%  -->
<!--   group_by(exp_nam) %>%  -->
<!--   summarise(nreplicates = n()) -->

<!-- ## for all variables, creates a named list -->
<!-- list_nreplicates <- purrr::map( list_co2_byvar, ~group_by(., exp_nam, treatment) %>%  -->
<!--   summarise(nrep = n()) ) %>%  -->
<!--   setNames(varlist) -->
<!-- ``` -->


# Data selection

Add two columns to the data. One for the new standard variable name (`varnam`), taken from CSV files. And one for this specific study where multiple variables (based on `varnames`) are pooled because they contain relevant and comparable information when evaluating response ratios (named `my_varnam`).

## General filters

We filter the data based on the following criteria:

- Only data from experiments is used where CO2 was the only manipulated factor (data from `treatment = "c"`)
- Only data from experiments where data from at least two years is available, based on column `Year` in the data table.
- Only data from Open Top Chambers or Free Air CO2 Enrichment CO2 experiments: fumigation type is either `"OTC"` or `"FACE"`. 

```{r warning=FALSE}
## Determine all experiments that have more than 1 year data
list_exp_gt1yr <- df %>% 
  filter(!is.na(Year)) %>% 
  group_by(exp_nam) %>% 
  summarise(nyears=max(Year)) %>% 
  filter(nyears>1) %>% 
  select(exp_nam) %>% 
  unlist() %>% 
  unname()

df_c <- df %>%
  
  # ## Take this info from experiments below
  # select(-Fumigation_type, -Vegetation_type) %>% 
  
  ## Add prev_name back
  left_join( df_experiments, by = "exp_nam") %>% 
  
  ## filter experiments with only manipulated CO2
  ## (no other factors manipulated, strong reduction of data)
  filter(treatment=="c") %>% 
  
  ## More than 1 year data
  filter(exp_nam %in% list_exp_gt1yr) %>% 
  
  ## Combine with experiments meta info
  left_join( 
    read_csv("~/data/gcme/data_received_190325/table_var_exp_names_experiments.csv") %>% 
      select(prev_name, Fumigation_type=my_fumigation_type, Vegetation_type),
    by = c("prev_name")
  ) %>% 
  
  ## Filter only Fumigation_type OTC or FACE
  filter( Fumigation_type %in% c("OTC", "FACE") ) %>%
  
  {.}
```

## Litter production




## ANPP

ANPP: `my_varnam = my_anpp`, and `varnam %in% c("anpp", "anpp_bm")`.

Collect information about experiments providing data for any of `varnam %in% c("anpp", "anpp_bm")`. See procedure [here](https://docs.google.com/document/d/11ghws59q6Ts6j6GK6yNqQBvilrNojRN_aC7c41-LrI0/edit?usp=sharing). Add additional information from the experiments table (`table_var_exp_names_experiments.csv`) and from the data frame `df_experiments`, which is used to associate new and old experiments names.
```{r, warning=FALSE}
df_anpp <- read_csv("~/data/gcme/data_received_190325/table_var_exp_names_anpp.csv") %>% 
  select(prev_name=expnam, varnam, Data_type, Source_Reference) %>%
  distinct() %>% 
  filter(varnam %in% c("anpp", "anpp_bm") ) %>% 
  
  ## add 'exp_nam' (new experiment name) from data table
  left_join( df_experiments, by="prev_name" ) %>% 
  
  ## filter only experiments selected by general filters above
  filter( exp_nam %in% unique(df_c$exp_nam) ) %>% 
  
  ## add experiments meta information from experiments table
  left_join( 
    read_csv("~/data/gcme/data_received_190325/table_var_exp_names_experiments.csv") %>% 
      select(prev_name, Fumigation_type=my_fumigation_type, Cquantity_Control, Cquantity_Treatment, Vegetation_type, Plants_specs, Start_Year, End_Year, Remarks),
    by = c("prev_name")
    )
```

Add `my_varnam` to the data table, defined by `my_varnam = ifelse( varnam %in% c("anpp", "anpp_bm"), "my_anpp", my_varnam )`. WARNING: This assumes that variable names 'Data_type' are identical in old and new dataset (manually replaced white spaces with underscores in table_var_exp_names_anpp.csv, first)
```{r, warning=FALSE}
df_c <- df_c %>% 
  mutate( varnam=NA ) %>% 
  left_join( select( df_anpp, -prev_name ), by=c("exp_nam", "Data_type") ) %>% 
  distinct(id, .keep_all=TRUE) %>% 
  rename( varnam = varnam.x ) %>% 
  rowwise() %>% 
  mutate( varnam = ifelse(!is.na(varnam.y), varnam.y, varnam ) ) %>% 
  select( -varnam.y ) %>% 
  mutate( my_varnam = NA ) %>% 
  mutate( my_varnam = ifelse( varnam %in% c("anpp", "anpp_bm"), "my_anpp", my_varnam ) )
```

And some information about the data used for `my_anpp` (only top 5 rows of a total of 110 available rows, full table at the bottom of this document)
```{r eval=FALSE}
df_anpp %>% 
  select(-prev_name, -Cquantity_Control) %>% 
  distinct(varnam, Data_type, exp_nam, .keep_all=TRUE) %>% 
  mutate( Source_Reference = str_replace_all(Source_Reference, "_", " ") ) %>% 
  knitr::kable()
```

## Leaf N

This analysis is done by mass, area, and C:N separately.

- `my_varnam = "my_nmass_leaf"`, and `varnam = "nmass_leaf"`.
- `my_varnam = "my_narea_leaf"`, and `varnam = "narea_leaf"`.
- `my_varnam = "my_rcton_leaf"`, and `varnam = "rcton_leaf"`.

Collect information about experiments providing data for any of `varnam %in% c("nmass_leaf", "narea_leaf", "rcton_leaf")` from file `"table_var_exp_names_leafn.csv"`. See procedure [here](https://docs.google.com/document/d/11ghws59q6Ts6j6GK6yNqQBvilrNojRN_aC7c41-LrI0/edit?usp=sharing). Add additional information from the experiments table (`table_var_exp_names_experiments.csv`) and from the data frame `df_experiments`, which is used to associate new and old experiments names.
```{r, warning=FALSE}
df_leafn <- read_csv("~/data/gcme/data_received_190325/table_var_exp_names_leafn.csv") %>% 
  select(prev_name=expnam, varnam, Data_type, Source_Reference) %>%
  distinct() %>% 
  filter(varnam %in% c("nmass_leaf", "narea_leaf", "rcton_leaf") ) %>% 
  
  ## add 'exp_nam' (new experiment name) from data table
  left_join( df_experiments, by="prev_name" ) %>% 
  
  ## filter only experiments selected by general filters above
  filter( exp_nam %in% unique(df_c$exp_nam) ) %>% 
  
  ## add experiments meta information from experiments table
  left_join( 
    read_csv("~/data/gcme/data_received_190325/table_var_exp_names_experiments.csv") %>% 
      select(prev_name, Fumigation_type=my_fumigation_type, Cquantity_Control, Cquantity_Treatment, Vegetation_type, Plants_specs, Start_Year, End_Year, Remarks),
    by = c("prev_name")
    )
```

Add `my_varnam` to the data table, defined by `my_varnam = ifelse( varnam == "nmass_leaf", "my_nmass_leaf", my_varnam )`.
```{r, warning=FALSE}
df_c <- df_c %>%
  left_join( select( df_leafn, exp_nam, Data_type, varnam_unified=varnam ), by=c("exp_nam", "Data_type") ) %>%
  mutate( varnam = ifelse( is.na(varnam), varnam_unified, varnam ) ) %>%
  mutate( my_varnam = ifelse( varnam == "nmass_leaf", "my_nmass_leaf", my_varnam ),
          my_varnam = ifelse( varnam == "narea_leaf", "my_narea_leaf", my_varnam ),
          my_varnam = ifelse( varnam == "rcton_leaf", "my_rcton_leaf", my_varnam )) %>%
  select(-varnam_unified)
```

## Asat

This analysis is done by Asat and Anet, that is at saturating and ambient PAR, respectively, and always at treatment CO2 levels.

- `my_varnam = "my_asat"`, and `varnam = "asat"`.
- `my_varnam = "my_anet"`, and `varnam = "anet"`.

Collect information about experiments providing data for any of `varnam %in% c("asat", "anet")` from file `"table_var_exp_names_asat.csv"`. See procedure [here](https://docs.google.com/document/d/11ghws59q6Ts6j6GK6yNqQBvilrNojRN_aC7c41-LrI0/edit?usp=sharing). Add additional information from the experiments table (`table_var_exp_names_experiments.csv`) and from the data frame `df_experiments`, which is used to associate new and old experiments names.
```{r, warning=FALSE}
df_asat <- read_csv("~/data/gcme/data_received_190325/table_var_exp_names_asat.csv") %>% 
  select(prev_name=expnam, varnam, Data_type, Source_Reference) %>%
  distinct() %>% 
  filter(varnam %in% c("asat", "anet") ) %>% 
  
  ## add 'exp_nam' (new experiment name) from data table
  left_join( df_experiments, by="prev_name" ) %>% 
  
  ## filter only experiments selected by general filters above
  filter( exp_nam %in% unique(df_c$exp_nam) ) %>% 
  
  ## add experiments meta information from experiments table
  left_join( 
    read_csv("~/data/gcme/data_received_190325/table_var_exp_names_experiments.csv") %>% 
      select(prev_name, Fumigation_type=my_fumigation_type, Cquantity_Control, Cquantity_Treatment, Vegetation_type, Plants_specs, Start_Year, End_Year, Remarks),
    by = c("prev_name")
    )  
```

Add `my_varnam` to the data table, defined by `my_varnam = ifelse( varnam == "nmass_leaf", "my_nmass_leaf", my_varnam )`.
```{r, warning=FALSE}
df_c <- df_c %>%
  left_join( select( df_asat, exp_nam, Data_type, varnam_unified=varnam ), by=c("exp_nam", "Data_type") ) %>%
  mutate( varnam = ifelse( is.na(varnam), varnam_unified, varnam ) ) %>%
  mutate( my_varnam = ifelse( varnam == "anet", "my_anet", my_varnam ),
          my_varnam = ifelse( varnam == "asat", "my_asat", my_varnam ) ) %>%
  select(-varnam_unified)
```


## BNPP

Let's pool various types of data to analyse response ratios of BNPP, interpreted here as a proxy for total belowground C allocation.

ANPP: `my_varnam = my_bnpp`, and `varnam %in% c("bnpp", "npp_fineroot", "npp_fineroot_length", "bm_fineroot", "bm_fineroot_mass", "bm_fineroot_vol", "bm_fineroot_length")`.

Collect information about experiments providing data for any of `varnam %in% c("asat", "anet")` from file `"table_var_exp_names_asat.csv"`. See procedure [here](https://docs.google.com/document/d/11ghws59q6Ts6j6GK6yNqQBvilrNojRN_aC7c41-LrI0/edit?usp=sharing). Add additional information from the experiments table (`table_var_exp_names_experiments.csv`) and from the data frame `df_experiments`, which is used to associate new and old experiments names.
```{r, warning=FALSE}
df_bnpp <- read_csv("~/data/gcme/data_received_190325/table_var_exp_names_bnpp.csv") %>% 
  select(prev_name=expnam, varnam, Data_type, Source_Reference) %>%
  distinct() %>% 
  filter(varnam %in% c("bnpp", "npp_fineroot", "npp_fineroot_length", "bm_fineroot", "bm_fineroot_mass", "bm_fineroot_vol", "bm_fineroot_length") ) %>% 
  
  ## add 'exp_nam' (new experiment name) from data table
  left_join( df_experiments, by="prev_name" ) %>% 
  
  ## filter only experiments selected by general filters above
  filter( exp_nam %in% unique(df_c$exp_nam) ) %>% 
  
  ## add experiments meta information from experiments table
  left_join( 
    read_csv("~/data/gcme/data_received_190325/table_var_exp_names_experiments.csv") %>% 
      select(prev_name, Fumigation_type=my_fumigation_type, Cquantity_Control, Cquantity_Treatment, Vegetation_type, Plants_specs, Start_Year, End_Year, Remarks),
    by = c("prev_name")
    ) %>% 
  
  ## String replace in CSV file
  mutate( Data_type = str_replace_all(Data_type, " ", "_") )
```

Add `my_varnam` to the data table, defined by `my_varnam = ifelse( varnam %in% c("bnpp", "npp_fineroot", "npp_fineroot_length", "bm_fineroot", "bm_fineroot_mass", "bm_fineroot_vol", "bm_fineroot_length")`.
```{r, warning=FALSE}
df_c <- df_c %>%
  left_join( select( df_bnpp, exp_nam, Data_type, varnam_unified=varnam ), by=c("exp_nam", "Data_type") ) %>%
  mutate( varnam = ifelse( is.na(varnam), varnam_unified, varnam ) ) %>%
  mutate( my_varnam = ifelse( varnam %in% c("bnpp", "npp_fineroot", "npp_fineroot_length", "bm_fineroot", "bm_fineroot_mass", "bm_fineroot_vol", "bm_fineroot_length"), "my_bnpp", my_varnam ) ) %>%
  select(-varnam_unified)
```


## N availability

Let's pool various types of data to analyse response ratios of N availability.

navl: `my_varnam = my_navl`, and `varnam %in% c("nmin_mass", "nmin_area", "nh4_mass", "no3_mass", "nmin_solution", "nh4_solution", "no3_solution", "nmin_resin", "nh4_resin", "no3_resin")`.

See procedure [here](https://docs.google.com/document/d/11ghws59q6Ts6j6GK6yNqQBvilrNojRN_aC7c41-LrI0/edit?usp=sharing). Add additional information from the experiments table (`table_var_exp_names_experiments.csv`) and from the data frame `df_experiments`, which is used to associate new and old experiments names.
```{r, warning=FALSE}
df_navl <- read_csv("~/data/gcme/data_received_190325/table_var_exp_names_navl.csv") %>% 
  select(prev_name=expnam, varnam, Data_type, Source_Reference) %>%
  distinct() %>% 
  filter(varnam %in% c("nmin_mass", "nmin_area", "nh4_mass", "no3_mass", "nmin_solution", "nh4_solution", "no3_solution", "nmin_resin", "nh4_resin", "no3_resin") ) %>% 
  
  ## add 'exp_nam' (new experiment name) from data table
  left_join( df_experiments, by="prev_name" ) %>% 
  
  ## filter only experiments selected by general filters above
  filter( exp_nam %in% unique(df_c$exp_nam) ) %>% 
  
  ## add experiments meta information from experiments table
  left_join( 
    read_csv("~/data/gcme/data_received_190325/table_var_exp_names_experiments.csv") %>% 
      select(prev_name, Fumigation_type=my_fumigation_type, Cquantity_Control, Cquantity_Treatment, Vegetation_type, Plants_specs, Start_Year, End_Year, Remarks),
    by = c("prev_name")
    ) %>% 
  
  ## String replace in CSV file
  mutate( Data_type = str_replace_all(Data_type, " ", "_") )
```

Add `my_varnam` to the data table, defined by `my_varnam = ifelse( varnam %in% c("nmin_mass", "nmin_area", "nh4_mass", "no3_mass", "nmin_solution", "nh4_solution", "no3_solution", "nmin_resin", "nh4_resin", "no3_resin")`.
```{r, warning=FALSE}
df_c <- df_c %>%
  left_join( select( df_navl, exp_nam, Data_type, varnam_unified=varnam ), by=c("exp_nam", "Data_type") ) %>%
  mutate( varnam = ifelse( is.na(varnam), varnam_unified, varnam ) ) %>%
  mutate( my_varnam = ifelse( varnam %in% c("nmin_mass", "nmin_area", "nh4_mass", "no3_mass", "nmin_solution", "nh4_solution", "no3_solution", "nmin_resin", "nh4_resin", "no3_resin"), "my_navl", my_varnam ) ) %>%
  select(-varnam_unified)
```

## Root:shoot ratio

Collect experiments info directly from data table.
```{r eval=FALSE}
df_c %>% 
  filter(Data_type=="root-shoot_ratio") %>% 
  select(exp_nam, prev_name, Fumigation_type.x, Vegetation_type.x ) %>% 
  distinct() %>% 
  knitr::kable()
```

Add `my_varnam` to the data table.
```{r}
df_c <- df_c %>%
  mutate( my_varnam = ifelse( Data_type == "root-shoot_ratio", "my_rootshootratio", my_varnam ) )
```


## N uptake

Collect experiments info directly from data table.
```{r eval=FALSE}
df_c %>% 
  filter(Data_type %in% c("N_uptake", "NH4+_uptake", "NO3-_uptake") ) %>% 
  select(exp_nam, prev_name, Fumigation_type.x, Vegetation_type.x ) %>% 
  distinct() %>% 
  knitr::kable()
```

Add `my_varnam` to the data table.
```{r}
df_c <- df_c %>%
  mutate( my_varnam = ifelse( Data_type %in% c("N_uptake", "NH4+_uptake", "NO3-_upttake") , "my_nup", my_varnam ) )
```


## N leaching

Collect experiments info directly from data table.
```{r eval=TRUE}
df_c %>% 
  filter(Data_type %in% c("N_leaching") ) %>% 
  select(exp_nam, prev_name, Fumigation_type.x, Vegetation_type.x ) %>% 
  distinct() %>% 
  View()
```

Add `my_varnam` to the data table.
```{r}
df_c <- df_c %>%
  mutate( my_varnam = ifelse( Data_type %in% c("N_leaching") , "my_nleach", my_varnam ) )
```

**SO FAR ONLY AVAILABLE FOR ONE EXPERIMENT. THEREFORE OMITTED IN META-ANALYSIS.**

## N2O emissions

Collect experiments info directly from data table.
```{r eval=TRUE}
df_c %>% 
  filter(Data_type == "soil_N2O_efflux" ) %>% 
  select(exp_nam, prev_name, Fumigation_type.x, Vegetation_type.x ) %>% 
  distinct() %>% 
  View()
```

Add `my_varnam` to the data table.
```{r}
df_c <- df_c %>%
  mutate( my_varnam = ifelse( Data_type %in% c("soil_N2O_efflux") , "my_n2o", my_varnam ) )
```

**SO FAR ONLY AVAILABLE FOR ONE EXPERIMENT. THEREFORE OMITTED IN META-ANALYSIS.**

## Soil C decomposition

Take data directly from Van Groenigen et al. (2014).
```{r eval=TRUE}
df_soilc_c <- read_csv(file="~/data/gcme/data_received_190325/soilc_decomp_vangroenigen14.csv") %>% 
  filter(treatment=="c") %>%
  
  ## Back-calculate SD of k from column wVk = 1/(SD_ambient^2/k_ambient^2 + SD_elevated^2/k_elevated^2)
  ## assuming that ambient_Sd = elevated_Sd
  rowwise() %>% 
  mutate( n_plots = n_experiments * n_ambient ) %>% 
  mutate( ambient_Sd = k_ambient * k_elevated / sqrt(wVk * (k_ambient^2 + k_elevated^2)) ) %>%
  mutate( elevated_Sd = ambient_Sd,
          varnam = "kdecay_soil",
          my_varnam = "my_kdecay_soil" ) %>% 
  left_join(df_experiments, by="prev_name")
  
df_c <- df_c %>% 
  full_join( 
    select(df_soilc_c, exp_nam, prev_name, varnam, my_varnam, exp_nam_vangroenigen, ambient=k_ambient, elevated=k_elevated, ambient_Sd, elevated_Sd, n_plots ),
    by = c("prev_name", "exp_nam", "ambient", "elevated", "ambient_Sd", "elevated_Sd", "varnam", "my_varnam", "n_plots"))
```

**ISSUE: No invormation on SD of decomposition rate estimates in ambient and elevated available.**


## For labeling

Prepare variable name association for labelling plots
```{r}
df_varnams <- tibble(
  my_varnam = c("my_anpp", "my_nmass_leaf", "my_narea_leaf", "my_asat", "my_anet", "my_bnpp", "my_navl",
                "my_rootshootratio", "my_nup",   "my_nleach",  "my_n2o",        "my_kdecay_soil"),
  my_lab    = c("ANPP",    "Leaf Nmass",    "Leaf Narea",    "Asat",    "Anet",    "BNPP",    "N availability",
                "root:shoot ratio",  "N uptake", "N leaching", "N2O emissions", "Soil decomposition rate")
)
```


# Data analysis 

Test analysis and plot of ANPP data. Calculate the response ratio of ANPP (mean and variance) for each experiment. To get that, we first need to calcuate the means and standard deviation for the ambient and elevated levels, pooling multiple measurements (years, sampling dates), each given with mean $\mu_i$, number $N_i$ (replicates/plots), and standard deviation $\sigma_i$ or standard error. For the function `metafor::escalc()`, we need standard deviations ($SD$). Calculate them for those rows where only standard errors $SE$ are given as:
$$
SD = SE \sqrt{N}
$$

Now, do the meta-analysis and plot results.
```{r, warning=FALSE}
## aggregate by variable and experiment, pooling multiple years, sampling dates, and plots/replicates and calculate log response ratio
df_c_sub <- df_c %>%         
  
  ## Here only for my variables, selected as described above 
  ## (leaving out "my_anet"; omitting "my_nleach" and "my_n2o" because only one experiment available)
  filter(my_varnam %in% c("my_anpp", "my_nmass_leaf", "my_narea_leaf", "my_asat", "my_bnpp", "my_navl", "my_rootshootratio", "my_nup", "my_kdecay_soil")) %>%
  
  # get standard deviation for all data
  mutate( my_ambient_sd = ambient_Sd, my_elevated_sd = elevated_Sd ) %>%
  rowwise() %>% 
  mutate( my_ambient_sd   = ifelse( is.na(my_ambient_sd),  ambient_Se  * sqrt(n_plots), my_ambient_sd ),
          my_elevated_sd  = ifelse( is.na(my_elevated_sd), elevated_Se * sqrt(n_plots), my_elevated_sd )) %>%

  ## Get logarithm of response ratio and its variance
  metafor::escalc( 
    measure = "ROM", 
    m1i = elevated, sd1i = my_elevated_sd, n1i = n_plots, 
    m2i = ambient,  sd2i = my_ambient_sd,  n2i = n_plots, 
    data=., 
    append = TRUE, var.names = c("logr", "logr_var") ) %>% 
  as_tibble() %>% 
  mutate( logr_se = sqrt(logr_var)/sqrt(n_plots) )

## pool all measurements (multiple years, sampling dates and plots) by variable and experiment for meta analysis
df_c_agg <- df_c_sub %>% 
  filter(!is.na(logr_var) & !is.na(logr)) %>% 
  select(-id) %>% # this is necessary because the dumb function agg() uses my 'id' otherwise
  mutate( id = paste(exp_nam, my_varnam, sep="_XXX_")) %>% 
  MAd::agg( id = id, es = logr, var = logr_var, n.1 = n_plots, n.2 = n_plots, cor = 1.0, method = "BHHR", data = . ) %>% 
  as_tibble() %>% 
  mutate( id = str_split(id, "_XXX_") ) %>% 
  mutate( exp_nam = purrr::map_chr(id, 1),
          my_varnam = purrr::map_chr(id, 2) ) %>% 
  select(exp_nam, my_varnam, es, var) %>% 

  ## add number of plots column and my_varnam
  left_join( df_c_sub %>% 
               group_by( exp_nam, my_varnam ) %>%
               summarise( n_plots = sum(n_plots) ) %>% 
               select( exp_nam, my_varnam, n_plots ),
             by = c("exp_nam", "my_varnam") ) %>% 
  rename( logr = es, logr_var = var ) %>% 
  mutate( logr_se = sqrt(logr_var)/sqrt(n_plots) ) %>% 
  left_join( df_varnams, by = "my_varnam" ) %>% 
  
  ## filter NA for exp_nam due to unidentified experiment name in soil decomposition dataset
  filter(exp_nam!="NA" & !is.na(exp_nam))

## aggregate by variable, doing a meta-analysis of the log response ratios, with experiment as random factor (method="DL")
agg_meta <- function(df, groupvar){
  
  out_meta <- df %>% dplyr::filter(my_varnam==eval(parse_character(groupvar))) %>% 
    
    # main meta analysis function call, adjusted step size (see http://www.metafor-project.org/doku.php/tips:convergence_problems_rma)
    # metafor::rma( logr, logr_var, method = "REML", slab = exp_nam, control = list(stepadj=0.3), data = . )
    metafor::rma.mv( logr, logr_var, method = "REML", random = ~ 1 | exp_nam, slab = exp_nam, control = list(stepadj=0.3), data = . )
  
  # transform back
  out_meta_scaled <- predict( out_meta, transf=exp )
  
  df_box <- tibble(
    my_varnam=groupvar, 
    middle = out_meta$b[1,1], 
    ymin   = out_meta$ci.lb, 
    ymax   = out_meta$ci.ub,
    
    middle_scaled = out_meta_scaled$pred, 
    ymin_scaled   = out_meta_scaled$ci.lb, 
    ymax_scaled   = out_meta_scaled$ci.ub
  )
  return(list(df_box=df_box, out_meta=out_meta))
}

# do meta-analysis on all variables
varlist <- unique(df_c_agg$my_varnam)
list_meta  <- purrr::map(as.list(varlist), ~agg_meta(df_c_agg, .))
df_metabox <- purrr::map_dfr(list_meta, "df_box") %>% left_join( df_varnams, by = "my_varnam" )
names(list_meta) <- varlist
```
Plot dots and my box
```{r}
df_c_agg %>%
  # arrange(logr) %>% 
  mutate( my_lab = factor(my_lab, levels=rev(c("Asat", "Leaf Nmass", "Leaf Narea", "ANPP", "N uptake", "N availability", "root:shoot ratio", "BNPP", "Soil decomposition rate")))) %>% 
  ggplot( aes(x=my_lab, y=logr)) +
  geom_jitter( color = rgb(0,0,0,0.3), aes( size = 1/logr_se ), position = position_jitter(w = 0.2, h = 0) ) +
  geom_crossbar( data = df_metabox, aes(x=my_lab, y=middle, ymin=ymin, ymax=ymax), fill = "grey80", alpha = 0.6, width = 0.5 ) +
  geom_hline( yintercept=0.0, size=0.5 ) +
  labs(x="", y="Log Response Ratio", size=expression(paste("Error"^{-1}))) +
  coord_flip() +
  ylim(-1,1) 
ggsave("fig/meta_myboxes.pdf", width=6, height=4)

## only ANPP, BNPP, root:shoot ratio
df_c_agg %>%
  filter(my_varnam %in% c("my_anpp", "my_bnpp", "my_rootshootratio")) %>% 
  mutate( my_lab = factor(my_lab, levels=rev(c("ANPP", "BNPP", "root:shoot ratio")))) %>%
  ggplot( aes(x=my_lab, y=logr)) +
  geom_jitter( color = rgb(0,0,0,0.3), aes( size = 1/logr_se ), position = position_jitter(w = 0.2, h = 0) ) +
  geom_crossbar( data = df_metabox %>% filter(my_varnam %in% c("my_anpp", "my_bnpp", "my_rootshootratio")), aes(x=my_lab, y=middle, ymin=ymin, ymax=ymax), fill = "grey80", alpha = 0.6, width = 0.5 ) +
  geom_hline( yintercept=0.0, size=0.5 ) +
  labs(x="", y="Log Response Ratio", size=expression(paste("Error"^{-1}))) +
  coord_flip() +
  ylim(-1,1) +
  theme(axis.text=element_text(size=12)) +
  theme_classic()

ggsave("fig/meta_myboxes_anpp_bnpp_rootshoot.pdf", width = 6, height = 3)

## only ANPP, BNPP, root:shoot ratio
df_c_agg %>%
  filter(my_varnam %in% c("my_rootshootratio", "my_nup")) %>% 
  ggplot( aes(x=my_lab, y=logr)) +
  geom_jitter( color = rgb(0,0,0,0.3), aes( size = 1/logr_se ), position = position_jitter(w = 0.2, h = 0) ) +
  geom_crossbar( data = df_metabox %>% filter(my_varnam %in% c("my_rootshootratio", "my_nup")), aes(x=my_lab, y=middle, ymin=ymin, ymax=ymax), fill = "grey80", alpha = 0.6, width = 0.5 ) +
  geom_hline( yintercept=0.0, size=0.5 ) +
  labs(x="", y="Log Response Ratio", size=expression(paste("Error"^{-1}))) +
  coord_flip() +
  ylim(-1,1) +
  theme(axis.text=element_text(size=12)) +
  theme_classic()

ggsave("fig/meta_myboxes_rootshoot_nuptake.pdf", width = 6, height = 3)

```

Number of data points (plot-level measurements) per variable:
```{r}
df_c_agg %>% 
  group_by(my_lab) %>% 
  summarise(n_plots=sum(n_plots), n_exp=n()) %>% 
  rename_("Variable"="my_lab", "N plots"="n_plots", "N experiments"="n_exp") %>% 
  knitr::kable()
```

## Forest plots

And the forest plots:
```{r}
forest_byvar <- function(list_meta, varnam_lab){
  par(mar=c(4,4,1,2))
  out_forest <- metafor::forest(list_meta$out_meta, xlab="Log Response Ratio", mlab="", xlim=c(-1,1), cex=0.5)
  text(out_forest$xlim[1], out_forest$ylim[2], varnam_lab,  pos=4, cex=0.7, font=2 )
}

df_varnams_sub <- df_varnams %>% filter(!(my_varnam %in% c("my_anet", "my_n2o", "my_nleach")))
purrr::map(
  as.list(1:nrow(df_varnams_sub)), 
  ~forest_byvar(list_meta[[df_varnams_sub$my_varnam[.]]], df_varnams_sub$my_lab[.])
  )
```

This shows the log-response ratio of ANPP, each dot for one experiment, multiple years, sampling dates, and plots pooled. The size of the dots represents the standard error of the response ratio (the smaller, the bigger). The box represents the meta-analysis mean and confidence interval of the log response ratio.

## Couplings

Plot effect sizes for two different variables against each other, given that data is available for both variables for a given experiment.

### ANPP-BNPP

```{r}
df_c_anpp_bnpp <- df_c_agg %>% 
  filter(my_lab %in% c("ANPP", "BNPP")) %>% 
  select(exp_nam, my_lab, logr) %>%
  tidyr::spread( my_lab, logr )

df_c_anpp_bnpp <- df_c_agg %>% 
  filter(my_lab %in% c("ANPP", "BNPP")) %>% 
  select(exp_nam, my_lab, logr_se) %>%
  tidyr::spread( my_lab, logr_se ) %>% 
  rename(seANPP=ANPP, seBNPP=BNPP) %>%
  right_join(df_c_anpp_bnpp, by="exp_nam") %>% 
  mutate(se = seANPP*seBNPP)

df_c_anpp_bnpp %>% 
  ggplot(aes(x=ANPP, y=BNPP, label=exp_nam)) +
  geom_point(aes(size=1/se)) +
  xlim(0, 0.8) + ylim(0, 0.8) +
  geom_abline() + 
  ggrepel::geom_text_repel(size=3, point.padding = 0.5, segment.alpha = 0) +
  labs(x="Log Response Ratio of ANPP", y="Log Response Ratio of BNPP", size=expression(paste("Error"^{-1})))
  # geom_errorbar(aes(ymin=BNPP-seBNPP, ymax=BNPP+seBNPP)) +
  # geom_errorbarh(aes(xmin=ANPP-seANPP, xmax=ANPP+seANPP))

ggsave("fig/meta_coupling_anpp_bnpp.pdf", width=6, height=4)
```

<!-- **Issue:** -->

<!-- - There are un-interpretable characters in files, concerning (most problematically) the experiments names. The problem is now, that these are in all data that is read in from multiple CSVs. Changing this by hand has to make sure that they are changed the same way in multiple files. -->
<!-- - Some old experiment names could not be associated with new experiments name because the old names given in the Excel table (sent 25.2.19) are not detected in the new data table (sent 25.3.19). This old-new name association is based on the columns `exp_nam` and `prev_name` in the new data table. For the following old experiment names, no new names could be found: -->
<!-- ```{r} -->
<!-- df_anpp %>% filter(is.na(exp_nam)) %>% select(prev_name) %>% distinct() %>% unlist() %>% unname() %>% print() -->
<!-- ``` -->
<!-- - The CO2 treatment levels are quite diverse. We should normalise the response ratio to that. How? -->


<!-- ## Leaf N -->


<!-- Now, do the meta-analysis and plot results. -->
<!-- ```{r, warning=FALSE} -->
<!-- # mean_pooled <- function( x, n ){ -->
<!-- #   sum(x * n)/sum(n) -->
<!-- # } -->
<!-- # sd_pooled <- function( sd, n ){ -->
<!-- #   sqrt( sum( (n-1)*sd^2 ) / sum(n-1) ) -->
<!-- # } -->

<!-- # ## aggregate by variable and experiment, pooling multiple years, sampling dates, and plots/replicates and calculate log response ratio -->
<!-- # df_c_leafn_agg <- df_c %>% -->
<!-- #   filter( my_varnam %in% c("my_nmass_leaf", "my_narea_leaf", "my_rcton_leaf") ) %>% -->
<!-- #   mutate( my_ambient_sd = ambient_Sd, my_elevated_sd = elevated_Sd ) %>%   # get standard deviation for all data -->
<!-- #   rowwise() %>% -->
<!-- #   mutate( my_ambient_sd   = ifelse( is.na(my_ambient_sd),  ambient_Se  * sqrt(n_plots), my_ambient_sd ), -->
<!-- #           my_elevated_sd  = ifelse( is.na(my_elevated_sd), elevated_Se * sqrt(n_plots), my_elevated_sd )) %>% -->

<!-- #   ## pool all measurements (multiple years, sampling dates and plots) by variable and experiment for meta analysis -->
<!-- #   group_by( exp_nam, treatment, my_varnam ) %>%                        # prepare for aggregation -->
<!-- #   summarise( ambient     = mean_pooled( ambient, n_plots ), -->
<!-- #              elevated    = mean_pooled( elevated, n_plots ), -->
<!-- #              ambient_sd  = sd_pooled( my_ambient_sd, n_plots ), -->
<!-- #              elevated_sd = sd_pooled( my_elevated_sd, n_plots ), -->
<!-- #              n_plots = sum(n_plots) ) %>% -->

<!-- #   ## Get logarithm of response ratio and its variance -->
<!-- #   metafor::escalc( -->
<!-- #     measure = "ROM", -->
<!-- #     m1i = elevated, sd1i = elevated_sd, n1i = n_plots, -->
<!-- #     m2i = ambient,  sd2i = ambient_sd,  n2i = n_plots, -->
<!-- #     data=., -->
<!-- #     append = TRUE, var.names = c("logr", "logr_var") ) %>% -->
<!-- #   as_tibble() %>% -->
<!-- #   mutate( logr_se = sqrt(logr_var)/sqrt(n_plots) ) -->

<!-- # ## aggregate by variable, doing a meta-analysis of the log response ratios, with experiment as random factor (method="DL") -->
<!-- # agg_meta <- function(df, groupvar){ -->
<!-- #   out_meta <- df %>% dplyr::filter(my_varnam==eval(parse_character(groupvar))) %>% -->
<!-- #     metafor::rma( logr, logr_var, method = "DL", data = . ) -->

<!-- #   # transform back -->
<!-- #   out_meta_scaled <- predict( out_meta, transf=exp ) -->

<!-- #   tibble( -->
<!-- #     my_varnam=groupvar, -->
<!-- #     middle = out_meta$b[1,1], -->
<!-- #     ymin   = out_meta$ci.lb, -->
<!-- #     ymax   = out_meta$ci.ub, -->

<!-- #     middle_scaled = out_meta_scaled$pred, -->
<!-- #     ymin_scaled   = out_meta_scaled$ci.lb, -->
<!-- #     ymax_scaled   = out_meta_scaled$ci.ub -->
<!-- #   ) -->
<!-- # } -->

<!-- # # do meta-analysis all variables -->
<!-- # df_meta <- purrr::map_dfr(as.list(unique(df_c_leafn_agg$my_varnam)), ~agg_meta(df_c_leafn_agg, .)) -->

<!-- # # Plot -->
<!-- # library(ggplot2) -->
<!-- # df_c_leafn_agg %>% -->
<!-- #   ggplot( aes(x=my_varnam, y=logr)) + -->
<!-- #   geom_jitter( color = rgb(0,0,0,0.3), aes( size = 1/logr_se ), position = position_jitter(w = 0.2, h = 0) ) + -->
<!-- #   geom_crossbar( data = df_meta, aes(x=my_varnam, y=middle, ymin=ymin, ymax=ymax), fill = "grey80", alpha = 0.6, width = 0.5 ) + -->
<!-- #   coord_flip() + -->
<!-- #   ylim(-1,1) -->

<!-- ## aggregate by variable and experiment, pooling multiple years, sampling dates, and plots/replicates and calculate log response ratio -->
<!-- df_c_leafn <- df_c %>%          -->

<!--   ## Here only for ANPP -->
<!--   filter( my_varnam %in% c("my_nmass_leaf", "my_narea_leaf") ) %>% -->

<!--   # get standard deviation for all data -->
<!--   mutate( my_ambient_sd = ambient_Sd, my_elevated_sd = elevated_Sd ) %>% -->
<!--   rowwise() %>%  -->
<!--   mutate( my_ambient_sd   = ifelse( is.na(my_ambient_sd),  ambient_Se  * sqrt(n_plots), my_ambient_sd ), -->
<!--           my_elevated_sd  = ifelse( is.na(my_elevated_sd), elevated_Se * sqrt(n_plots), my_elevated_sd )) %>% -->

<!--   ## Get logarithm of response ratio and its variance -->
<!--   metafor::escalc(  -->
<!--     measure = "ROM",  -->
<!--     m1i = elevated, sd1i = my_elevated_sd, n1i = n_plots,  -->
<!--     m2i = ambient,  sd2i = my_ambient_sd,  n2i = n_plots,  -->
<!--     data=.,  -->
<!--     append = TRUE, var.names = c("logr", "logr_var") ) %>%  -->
<!--   as_tibble() %>%  -->
<!--   mutate( logr_se = sqrt(logr_var)/sqrt(n_plots) ) -->

<!-- ## pool all measurements (multiple years, sampling dates and plots) by variable and experiment for meta analysis -->
<!-- df_c_leafn_agg <- df_c_leafn %>%  -->
<!--   filter(!is.na(logr_var) & !is.na(logr)) %>%  -->
<!--   select(-id) %>% # this is necessary because the dumb function agg() uses my 'id' otherwise -->
<!--   MAd::agg( id = exp_nam, es = logr, var = logr_var, n.1 = n_plots, n.2 = n_plots, cor = 1.0, method = "BHHR", data = . ) %>%  -->
<!--   rename( exp_nam = id ) %>%  -->

<!--   ## add number of plots column and my_varnam -->
<!--   left_join( df_c_leafn %>%  -->
<!--                group_by( exp_nam ) %>% -->
<!--                summarise( n_plots = sum(n_plots) ) %>%  -->
<!--                select( exp_nam, n_plots ), -->
<!--              by = "exp_nam" ) %>%  -->
<!--   rename( logr = es, logr_var = var ) %>%  -->
<!--   mutate( logr_se = sqrt(logr_var)/sqrt(n_plots), -->
<!--           my_varnam = "my_leafn" ) -->

<!-- ## aggregate by variable, doing a meta-analysis of the log response ratios, with experiment as random factor (method="DL") -->
<!-- agg_meta <- function(df, groupvar){ -->
<!--   out_meta <- df %>% dplyr::filter(my_varnam==eval(parse_character(groupvar))) %>%  -->
<!--     metafor::rma( logr, logr_var, method = "REML", slab = exp_nam, data = . ) -->

<!--   # transform back -->
<!--   out_meta_scaled <- predict( out_meta, transf=exp ) -->

<!--   df_box <- tibble( -->
<!--     my_varnam=groupvar,  -->
<!--     middle = out_meta$b[1,1],  -->
<!--     ymin   = out_meta$ci.lb,  -->
<!--     ymax   = out_meta$ci.ub, -->

<!--     middle_scaled = out_meta_scaled$pred,  -->
<!--     ymin_scaled   = out_meta_scaled$ci.lb,  -->
<!--     ymax_scaled   = out_meta_scaled$ci.ub -->
<!--   ) -->
<!--   return(list(df_box=df_box, out_meta=out_meta)) -->
<!-- } -->

<!-- # do meta-analysis on all variables -->
<!-- list_meta  <- purrr::map(as.list(unique(df_c_leafn_agg$my_varnam)), ~agg_meta(df_c_leafn_agg, .)) -->
<!-- df_metabox <- purrr::map_dfr(list_meta, "df_box") -->

<!-- # Plot dots and my box -->
<!-- library(ggplot2) -->
<!-- df_c_leafn_agg %>% -->
<!--   ggplot( aes(x=my_varnam, y=logr)) + -->
<!--   geom_jitter( color = rgb(0,0,0,0.3), aes( size = 1/logr_se ), position = position_jitter(w = 0.2, h = 0) ) + -->
<!--   geom_crossbar( data = df_metabox, aes(x=my_varnam, y=middle, ymin=ymin, ymax=ymax), fill = "grey80", alpha = 0.6, width = 0.5 ) + -->
<!--   coord_flip() + -->
<!--   ylim(-1,1) -->

<!-- # Forest plot -->
<!-- par(mar=c(4,4,1,2)) -->
<!-- out_forest <- metafor::forest(list_meta[[1]]$out_meta, xlab="Log Response Ratio", mlab="", xlim=c(-1,1), cex=0.5) -->
<!-- ``` -->

<!-- Data used for leaf N calculations: -->
<!-- ```{r eval=FALSE} -->
<!-- df_leafn %>% select(-prev_name, -Cquantity_Control) %>% distinct(varnam, Data_type, exp_nam, .keep_all=TRUE) %>% knitr::kable() -->
<!-- ``` -->


<!-- ## Asat -->


<!-- Now, do the meta-analysis and plot results. -->
<!-- ```{r, warning=FALSE} -->
<!-- ## aggregate by variable and experiment, pooling multiple years, sampling dates, and plots/replicates and calculate log response ratio -->
<!-- df_c_leafn_agg <- df_c %>% -->
<!--   filter( my_varnam %in% c("my_nmass_leaf", "my_narea_leaf", "my_rcton_leaf") ) %>% -->
<!--   mutate( my_ambient_sd = ambient_Sd, my_elevated_sd = elevated_Sd ) %>%   # get standard deviation for all data -->
<!--   rowwise() %>% -->
<!--   mutate( my_ambient_sd   = ifelse( is.na(my_ambient_sd),  ambient_Se  * sqrt(n_plots), my_ambient_sd ), -->
<!--           my_elevated_sd  = ifelse( is.na(my_elevated_sd), elevated_Se * sqrt(n_plots), my_elevated_sd )) %>% -->

<!--   ## pool all measurements (multiple years, sampling dates and plots) by variable and experiment for meta analysis -->
<!--   group_by( exp_nam, treatment, my_varnam ) %>%                        # prepare for aggregation -->
<!--   summarise( ambient     = mean_pooled( ambient, n_plots ), -->
<!--              elevated    = mean_pooled( elevated, n_plots ), -->
<!--              ambient_sd  = sd_pooled( my_ambient_sd, n_plots ), -->
<!--              elevated_sd = sd_pooled( my_elevated_sd, n_plots ), -->
<!--              n_plots = sum(n_plots) ) %>% -->

<!--   ## Get logarithm of response ratio and its variance -->
<!--   metafor::escalc( -->
<!--     measure = "ROM", -->
<!--     m1i = elevated, sd1i = elevated_sd, n1i = n_plots, -->
<!--     m2i = ambient,  sd2i = ambient_sd,  n2i = n_plots, -->
<!--     data=., -->
<!--     append = TRUE, var.names = c("logr", "logr_var") ) %>% -->
<!--   as_tibble() %>% -->
<!--   mutate( logr_se = sqrt(logr_var)/sqrt(n_plots) ) -->

<!-- ## aggregate by variable, doing a meta-analysis of the log response ratios, with experiment as random factor (method="DL") -->
<!-- agg_meta <- function(df, groupvar){ -->
<!--   out_meta <- df %>% dplyr::filter(my_varnam==eval(parse_character(groupvar))) %>% -->
<!--     metafor::rma( logr, logr_var, method = "DL", data = . ) -->

<!--   # transform back -->
<!--   out_meta_scaled <- predict( out_meta, transf=exp ) -->

<!--   tibble( -->
<!--     my_varnam=groupvar, -->
<!--     middle = out_meta$b[1,1], -->
<!--     ymin   = out_meta$ci.lb, -->
<!--     ymax   = out_meta$ci.ub, -->

<!--     middle_scaled = out_meta_scaled$pred, -->
<!--     ymin_scaled   = out_meta_scaled$ci.lb, -->
<!--     ymax_scaled   = out_meta_scaled$ci.ub -->
<!--   ) -->
<!-- } -->

<!-- # do meta-analysis all variables -->
<!-- df_meta <- purrr::map_dfr(as.list(unique(df_c_leafn_agg$my_varnam)), ~agg_meta(df_c_leafn_agg, .)) -->

<!-- # Plot -->
<!-- library(ggplot2) -->
<!-- df_c_leafn_agg %>% -->
<!--   ggplot( aes(x=my_varnam, y=logr)) + -->
<!--   geom_jitter( color = rgb(0,0,0,0.3), aes( size = 1/logr_se ), position = position_jitter(w = 0.2, h = 0) ) + -->
<!--   geom_crossbar( data = df_meta, aes(x=my_varnam, y=middle, ymin=ymin, ymax=ymax), fill = "grey80", alpha = 0.6, width = 0.5 ) + -->
<!--   coord_flip() + -->
<!--   ylim(-1,1) -->
<!-- ``` -->

<!-- Data used for leaf N calculations: -->
<!-- ```{r eval=FALSE} -->
<!-- df_leafn %>% select(-prev_name, -Cquantity_Control) %>% distinct(varnam, Data_type, exp_nam, .keep_all=TRUE) %>% knitr::kable() -->
<!-- ``` -->







<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("ANPP", "annual_aboveground_biomass_production", "aboveground_production", "annual_aboveground_biomass_production", "aboveground_biomass_production"), "my_anpp", my_var ) ) -->

<!-- ## NEW: -->
<!-- df_wide_c <- df_wide_c %>%  -->
<!--   mutate( my_var = ifelse( Data_type=="ANPP" & exp_nam=="BioCON", "my_anpp", my_var ) ) %>%  -->
<!--   mutate( my_var = ifelse( Data_type=="ANPP" & exp_nam=="asdf",   "my_anpp", my_var ) ) %>%  -->

<!-- ``` -->

<!-- - N uptake: `N_uptake`, `NH4+_uptake` (**OK here?**),  -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("N_uptake", "NH4+_uptake"), "my_nup", my_var ) ) -->
<!-- ``` -->

<!-- - N availability: `nmin_mass`, `nh4_mass`, `no3_mass`, `nmin_solution`, `nh4_solution`, `no3_solution`, `nmin_resin`, `nh4_resin`, `no3_resin` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("soil_NO3-", "soil_NH4+", "soil_NH4-N", "soil_mineral_N", "mineral_soil_N", "resin_NH4+", "resin_NO3-"), "my_navl", my_var ) ) -->
<!-- ``` -->

<!-- - N fixation: `number_of_nodes` **Only this data available?** -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("number_of_nodes"), "my_nfix", my_var ) ) -->
<!-- ``` -->

<!-- - Belowground C allocation: `root_biomass`, `root_biomass_(>2mm)`, `root_C`, `root_growth`, `root_mass`, `belowground_biomass`, `belowground_biomass_C`, `belowground_C`, `coarse_root_biomass` (**OK here?**), `fine_root_biomass`, `fine_root_production`, `BNPP`, `root_biomass_input` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("root_biomass", "root_biomass_(>2mm)", "root_C", "root_growth", "root_mass", "belowground_biomass", "belowground_biomass_C", "belowground_C", "coarse_root_biomass", "fine_root_biomass", "fine_root_production", "BNPP", "root_biomass_input"), "my_croot", my_var ) ) -->
<!-- ``` -->

<!-- - Root:shoot ratio: `root-shoot_ratio`, `R/S` (**Is that what it means?**) -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("root-shoot_ratio", "R/S"), "my_rootshoot", my_var ) ) -->
<!-- ``` -->

<!-- - SOM decomposition: `litter_decomposition` (**OK only if it's a relative rate**), `net_C_mineralization`, `aboveground_litter_C_mineralization`, `belowground_litter_C_mineralization` (**Is this all we have?**) -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("litter_decomposition", "net_C_mineralization", "aboveground_litter_C_mineralization", "belowground_litter_C_mineralization"), "my_decomp", my_var ) ) -->
<!-- ``` -->


<!-- - Net N mineralization: `potential_net_N_mineralization`, `net_N_mineralization`, `soil_N_mineralization` (**Check whether this is net or gross**) -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("potential_net_N_mineralization", "net_N_mineralization", "soil_N_mineralization"), "my_nmin", my_var ) ) -->
<!-- ``` -->


<!-- - N losses: `soil_N2O_efflux`, `soil_N_efflux`, `15N_recovery` (**Look into this**), `N_leaching`, `NO3-_leaching` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("soil_N2O_efflux", "soil_N_efflux", "N_leaching", "NO3-_leaching"), "my_nloss", my_var ) ) -->
<!-- ``` -->

<!-- - leaf N: `nmass_leaf`, `narea_leaf`, `rcton_leaf`, `nareaground_canopy`, `nareaground_agbm`, `nmass_agbm`, `rcton_agbm` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("leaf_N"), "my_nleaf", my_var ) ) -->
<!-- ``` -->

<!-- - Tissue C:N: `total_biomass_C:N`, `belowground_biomass_C:N`, `leaf_litter_N` (**OK here?**), `fine_root_N` (**OK here?**), `aboveground_biomass_C:N`, `leaf_litter_C:N`, `fine_root_C:N`, `wood_C/N` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("total_biomass_C:N", "belowground_biomass_C:N", "aboveground_biomass_C:N", "leaf_litter_C:N", "fine_root_C:N`", "wood_C/N"), "my_rcton", my_var ) ) -->
<!-- ``` -->

<!-- Potentially interesting as well: -->

<!-- - Resorption: `resorption_efficiency` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("resorption_efficiency"), "my_nresorp", my_var ) ) -->
<!-- ``` -->

<!-- - Biomass: `biomass_C`, `total_biomass` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("biomass_C", "total_biomass"), "my_ctot", my_var ) ) -->
<!-- ``` -->

<!-- - Aboveground biomass: `aboveground_biomass`, `Aboveground_biomass` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("aboveground_biomass", "Aboveground_biomass"), "my_caboveground", my_var ) ) -->
<!-- ``` -->

<!-- - Mycorrhizal stuff: `mycorrhizal_colonization`, `mycorrhizal_root_colonization` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("mycorrhizal_colonization", "mycorrhizal_root_colonization"), "my_myc", my_var ) ) -->
<!-- ``` -->

<!-- - Exudation: `DOC_exudation`, `exudation`, `Exudation` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("DOC_exudation", "exudation", "Exudation"), "my_cexu", my_var ) ) -->
<!-- ``` -->


<!-- # Data analysis -->

<!-- ## With old format -->

<!-- As a first analysis, for all the experiments with manipulated CO2, we calculate the mean log-response ratio (`logr`) and the number of data points (`n_plots`), aggregated by variable (`Data_type`), experiment (`exp_nam`) and treatment (`treatment`). -->

<!-- ```{r, warning=FALSE} -->
<!-- library(metafor)   # see ?dat.curtis1998 for an example with CO2 manipulation data -->
<!-- df_c <- df %>%                                          -->
<!--   filter(treatment=="c") %>%   # filter experiments with only manipulated CO2 (no other factors manipulated, strong reduction of data) -->
<!--   mutate( my_ambient_sd = ambient_Sd, my_elevated_sd = elevated_Sd ) %>%   # get standard deviation for all data -->
<!--   rowwise() %>%  -->
<!--   mutate( my_ambient_sd   = ifelse( is.na(my_ambient_sd),  ambient_Se  * sqrt(n_plots), my_ambient_sd ), -->
<!--           my_elevated_sd  = ifelse( is.na(my_elevated_sd), elevated_Se * sqrt(n_plots), my_elevated_sd )) %>% -->
<!--   metafor::escalc(  -->
<!--     measure = "ROM",  -->
<!--     m1i = elevated, sd1i = my_elevated_sd, n1i = n_plots,  -->
<!--     m2i = ambient,  sd2i = my_ambient_sd,  n2i = n_plots,  -->
<!--     data=.,  -->
<!--     append = TRUE, var.names = c("logr", "logr_sd") ) -->

<!--   mutate( logr = log(elevated/ambient) ) %>%              # calculate log response ratio -->
<!--   group_by( exp_nam, my_var, treatment ) %>%              # prepare for aggregation -->
<!--   summarise( logr = mean(logr, na.rm=TRUE), n_plots = sum(n_plots) )   # This is a dumb mean, not taking into account the standard error and N. Warning also for na.rm = TRUE. -->
<!-- ``` -->

<!-- **Issue:** -->

<!-- - Is number of plots (`n_plots`) always identical for ambient and elevated? It's not distinguished in the dataset. -->


<!-- ## With new format -->

<!-- **TODO:** -->

<!-- - Do this aggregation once the wide-to-long and long-to-wide steps are working correctly (see tests above). Then the following can be executed: -->

<!-- As a first analysis, for all the experiments with manipulated CO2, we calculate the mean log-response ratio (`logr`) and the number of data points (`n_plots`), aggregated by variable (`Data_type`), experiment (`exp_nam`) and treatment (`treatment`). -->


<!-- ```{r, warning=FALSE, eval=FALSE} -->
<!-- df_meta <- df_wide_c %>%                                             # only experiments with manipulated CO2 -->
<!--   mutate( my_ambient_sd = ambient_sd, my_elevated_sd = elevated_sd ) %>%   # get standard deviation for all data -->
<!--   rowwise() %>%  -->
<!--   mutate( my_ambient_sd   = ifelse( is.na(my_ambient_sd),  ambient_se  * sqrt(n_plots), my_ambient_sd ), -->
<!--           my_elevated_sd  = ifelse( is.na(my_elevated_sd), elevated_se * sqrt(n_plots), my_elevated_sd )) -->

<!--   mutate( my_ambient_sd  = ifelse( is.na(my_ambient_sd),  ambient_se  * sqrt(n_plots), ambient_sd ),        # SD = SE * sqrt(N) -->
<!--           my_elevated_sd = ifelse( is.na(my_elevated_sd), elevated_se * sqrt(n_plots), elevated_sd) ) %>%   # SD = SE * sqrt(N) -->
<!--   mutate( logr = log(elevated/ambient) ) %>%              # calculate log response ratio -->
<!--   group_by( exp_nam, my_var, f ) %>%              # prepare for aggregation -->
<!--   summarise( logr = mean(logr, na.rm=TRUE), n_plots = sum(n_plots) )   # This is a dumb mean, not taking into account the standard error and N. Warning also for na.rm = TRUE. -->
<!-- ``` -->

<!-- ## Plot -->

<!-- Plot all variables. -->
<!-- ```{r, warning=FALSE} -->
<!-- library(ggplot2) -->
<!-- df_meta %>% filter(!is.na(my_var)) %>%  -->
<!--   ggplot( aes(x=my_var, y=logr)) + -->
<!--   geom_jitter( color = rgb(0,0,0,0.3), aes( size = n_plots ), position = position_jitter(w = 0.3, h = 0) ) + -->
<!--   geom_boxplot( outlier.shape=NA, fill = "grey80", alpha = 0.6, width = 0.5 ) + -->
<!--   coord_flip() + -->
<!--   ylim(-2,2) -->
<!-- ``` -->

<!-- # Experiments tables by variable -->

<!-- ## ANPP -->

<!-- ```{r} -->
<!-- df_anpp %>% select(-prev_name, -Cquantity_Control) %>% distinct(varnam, Data_type, exp_nam, .keep_all=TRUE) %>% knitr::kable() -->
<!-- ``` -->

