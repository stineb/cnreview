---
title: "CO2 experimental data analysis"
author: "Beni Stocker"
date: "`r Sys.Date()`"
output:
  html_document:
    #theme: paper
    toc: true
    toc_float: true
    toc_depth: 2
# output:
#   pdf_document:
#     toc: true
#     toc_depth: 2
header-includes:
   - \usepackage{amsmath}
# bibliography: bibliography.bib
---


# Data screening

For a first data screening want to do the following:

1. Get data from eCO2 experiments
2. Data availability per experiment
3. Data availability per variable
4. Long versus wide issue

Let's check first if the data is ready to use for these steps.

But before we start:

- Some variable names end with an underscore (`ANPP_`, `Asat_`, `SLA_`, `coarse_root_biomass_`, `LMA_`, `soil_NH4+_`, `N_uptake_`). Needed to delete that manually.
- Replaced lots of superscripted numbers (actually appeared as superscript when opening the CSV file in my text editor) with plain number (e.g., `m2`)
- Replaced units given like `g_m-2` with `g/m2`, or `kg_ha-1` with `kg/ha`, or `g/m2*yr` with `g/m2/yr` (assuming that's correct if that's the way it would be entered in R), `_g/m2` with `g/m2`, `cm2/m2*d` with `cm2/m2/d`, ... I'll leave it with that for now.
- Replaced `Vcmax_normalized_to_25°C` with `Vcmax25`, and `Jmax_normalized_to_25°C` with `Jmax25` (problematic degree sign)
- Removed weird symbol in units, e.g., `‘mol_CO2/m2/s` to `mol_CO2/m2/s`
- Removed line break in date string

**All that is saved as a new file `NewData_wide_CORRECTED2.csv`**

Load the corrected file, which is based on the one Kevin sent on 1.3.2019.
```{r, warning=FALSE}
library(readr)
library(dplyr)
df <- read_csv("~/data/gcme/data_received_190325/NewData_wide_CORRECTED2.csv") %>%
  
  # something is wrong in columns ambient_Sd, ambient_Se, elevated...
  mutate( ambient_Sd  = as.numeric(ambient_Sd),  ambient_Se  = as.numeric(ambient_Se), 
          elevated_Sd = as.numeric(elevated_Sd), elevated_Se = as.numeric(elevated_Se) )
  
  # XXX testing
  # filter(exp_nam == "SwissFACE_lolium2" & Data_type == "aboveground_biomass")
  # filter(exp_nam == "SwissFACE_trifolium2" & Data_type == "aboveground_biomass")

# save experiments names
df_experiments <- df %>% select(exp_nam, prev_name) %>% distinct()
```

## 0. Issues

### Sampling date

This is not read in correctly. Either continue doing manual edits (open CSV in editor and check whether it's in a consistent format, at least within experiments), or do something clever if sampling date formats are at least consistent within experiments: e.g., reading the table experiment per experiment (making use of automatic interpretation of the sampling date format by read_csv()) and then stack all experiments' data together again.

### Duplicate rows

Some rows are simply duplicates. This is dangerous.
```{r}
keyvars <- c("exp_nam", "factors", "treatment", "Data_type", "Unit", "Sampling_date", "Start_Year", "Year", "n_plots")
valuevars <-  c("ambient", "ambient_Se", "ambient_Sd", "elevated", "elevated_Se", "elevated_Sd")

df %>% 
  filter(exp_nam == "SwissFACE_trifolium2" & Data_type == "aboveground_biomass") %>% 
  filter(treatment=="cf") %>% 
  select(one_of(keyvars, valuevars)) %>% 
  print()
```

This may be remediated automatically by using only columns that are distinct w.r.t. `valuevars` and `keyvars` (basically all columns in original data, except `ALIAS`).
```{r}
print(nrow(df))
df <- df %>% 
  distinct_at(vars(one_of(keyvars, valuevars))) %>%
  mutate( id=1:n() )   # create new ID key (before this was 'ALIAS')
print(nrow(df))

df %>% 
  filter(exp_nam == "SwissFACE_trifolium2" & Data_type == "aboveground_biomass") %>% 
  filter(treatment=="cf") %>% 
  select(one_of(keyvars, valuevars)) %>% 
  print()
```

Still problems?
```{r}
df %>% 
  filter(exp_nam == "SwissFACE_lolium2" & Data_type == "belowground_biomass") %>% 
  filter(treatment=="cf", Year==6) %>% 
  select(one_of(keyvars, valuevars)) %>% 
  print()
```
Yes. In this case, the problem has to do with `Sampling_date`. I suspect that the problem with `Sampling_date` is that it was manually entered and consistency may be respected within experiments (and variables?), but not across variables. When read into R with `readr::read_csv()`, different formats are interpreted always with the same function. A possible solution to this is to read data separately for each experiment and variable and stack them together again (`bind_rows()`).

**TODO:**

- First, do some manual cleaning of `Sampling_date` as far as possible and reasonable. Then, develop a separate read-in by experiments and variables, stack data again, and write the combined data to file.

### Distinct ambients

The way the wide format is designed, the ambient values should be the same for different rows corresponding to different treatments (for a given experiment, variable, and sampling year). This is not always the case. It might be that these are actually different data from multiple samplings. However, this is not identifiable, but should be. An example:
```{r}
df %>% 
  filter(exp_nam == "SwissFACE_lolium2" & Data_type == "Rh" ) %>% 
  print()
```

**TODO:**

- I haven't figured out how to do a bulk check on this and resolve it. It doesn't affect too many entries. Hence, it might have to be cleaned by hand.

<!-- ## 1. Get data from eCO2 experiments -->

<!-- Get information on what factors (`factors`) are available: -->
<!-- ```{r, warning=FALSE} -->
<!-- library(dplyr) -->
<!-- unique(df$factors) %>% print() -->
<!-- ``` -->

<!-- Great! This looks nice and clean. There is one `"x99"`, coming from the "Niigata" experiment, which needs to be corrected. -->

<!-- Filter only data from experiments where CO2 was manipulated. The way the data is organised here, a full factorial (eCO2 x N-fertilisation) experiment, which has four treatments (including the control), should have three rows in our dataset: eCO2-only, N-fertilisation-only, eCO2 $\times$ N-fertilisation). Such an experiment is identified as `factors %in% c("cf", "fc")`. SwissFACE_lolium2 is an example for such an experiment: -->

<!-- ```{r, warning=FALSE} -->
<!-- df %>% filter( exp_nam == "SwissFACE_lolium2" ) %>% select(exp_nam, factors, treatment) %>% unique() %>% print() -->
<!-- ``` -->
<!-- Confirmed. -->

<!-- For our analysis, we're only interested in the treatments where CO2 was elevated. That is, `treatment` should contain a `"c"`. Filter only this data by: -->
<!-- ```{r, warning=FALSE} -->
<!-- df_co2 <- df %>% filter( grepl("c", treatment) ) -->
<!-- ``` -->

<!-- **Issue:** -->

<!-- - Maybe it makes sense to exclude experiments where N was added. Does it? -->

<!-- ```{r, warning=FALSE} -->
<!-- df_co2 <- df_co2 %>% filter( !grepl("f", treatment) ) -->
<!-- ``` -->


<!-- We have a stunning ... -->
<!-- ```{r, warning=FALSE} -->
<!-- print( paste( "... number of data points:", nrow(df_co2) ) ) -->
<!-- ``` -->


<!-- ## 2. Data availability per experiment -->

<!-- For each experiment, collect all available variables. -->
<!-- ```{r, warning=FALSE} -->
<!-- library(purrr) -->
<!-- library(tidyr) -->
<!-- #exp_varlist <- purrr::map( as.list(unique(df_co2$exp_nam)), ~filter(df_co2, exp_nam==.) %>% select(Data_type) %>% unlist() %>% unique() ) %>%  -->
<!-- #  setNames( unique(df_co2$exp_nam) ) -->

<!-- df_avl_byexp <- df_co2 %>%  -->
<!--   mutate( n_plots = as.integer(n_plots) ) %>%  -->
<!--   group_by( exp_nam ) %>%  -->
<!--   nest() %>%  -->
<!--   mutate( variables = purrr::map( data, ~unique( .$Data_type ) ), -->
<!--           factors   = purrr::map( data, ~unique( .$factors ) ), -->
<!--           treatment = purrr::map( data, ~unique( .$treatment ) ) -->
<!--         ) %>%  -->
<!--   mutate( n_variables = purrr::map_int( variables, ~length(.)), -->
<!--           n_factors   = purrr::map_int( factors,   ~length(.)), -->
<!--           n_treatment = purrr::map_int( treatment, ~length(.)), -->
<!--           n_datap     = purrr::map_int( data, ~sum(.$n_plots))  -->
<!--           ) -->

<!-- # show top 100 rows -->
<!-- df_avl_byexp %>%  -->
<!--   select(exp_nam, factors, treatment, n_variables, n_datap ) %>%  -->
<!--   arrange( desc(n_datap) ) %>% -->
<!--   slice( 1:100 ) %>%  -->
<!--   knitr::kable() #slice(1:50) %>% View() #  -->
<!-- ``` -->

<!-- **Issue:** -->

<!-- - For some experiments, multiple different entries are available for `factors`. Shouldn't this always be a single entry for factor for a given experiment? -->

<!-- ## 3. Get CO2 effect -->

<!-- First, create a data frame that contains information for each experiment, whether Asat data is available. Not sure if we need that, actually... -->
<!-- ```{r eval=FALSE} -->
<!-- library(tidyr) -->
<!-- exp_co2_asat <- purrr::map_dfc( exp_varlist, ~is.element("Asat", .) ) %>%  -->
<!--   gather("exp_name", "avl_Asat") -->
<!-- ``` -->

<!-- Calculate (or extract) the CO2 effect (log-response) and its error for each variable of interest for which we have data, for each experiment separately. Let's start with one variable: `Asat` (and hope that's how it's called for all experiments). -->

<!-- ```{r, warning=FALSE} -->
<!-- df_co2_asat <- df_co2 %>% filter( Data_type=="Asat" )  -->
<!-- ``` -->

<!-- Once we have a list of variables, and the exact and consistent variable names in the dataset we can create a list of data frames as: -->
<!-- ```{r, warning=FALSE} -->
<!-- varlist <- c("Asat", "decomp", "leafN", "anpp" )  # just an example -->
<!-- list_co2_byvar <- purrr::map( as.list(varlist), ~filter(df_co2, Data_type == .)) %>%  -->
<!--   setNames(varlist) -->
<!-- ``` -->


<!-- ## 3. Data availability per variable -->

<!-- Summarise data availability per variable (`Data_type`): -->

<!-- - One column for number of "experiments". Here, different treatments within one experiments (`exp_nam`) are counted as separate "experiments". -->
<!-- - One  -->

<!-- ```{r, warning=FALSE} -->
<!-- library(knitr) -->
<!-- # second way -->
<!-- df_avl_byvar <- df_co2 %>%  -->
<!--   mutate( n_plots = as.integer(n_plots) ) %>%  -->
<!--   group_by( Data_type ) %>%  -->
<!--   nest() %>%  -->
<!--   mutate( experiments = purrr::map( data, ~unique( .$exp_nam ) ) ) %>%  -->
<!--   mutate( n_experiments = purrr::map_int( experiments, ~length(.)), -->
<!--           n_datap       = purrr::map_int( data, ~sum(.$n_plots)), -->
<!--           n_exp_treat   = purrr::map_int( data, ~n_distinct(.$exp_nam, .$treatment)) -->
<!--           ) -->

<!-- # show top 100 rows by n_datap -->
<!-- df_avl_byvar %>%  -->
<!--   arrange(desc(n_datap)) %>%  -->
<!--   select(Data_type, n_experiments, n_exp_treat, n_datap) %>%  -->
<!--   slice(1:50) %>%  -->
<!--   knitr::kable() #%>% View() # -->

<!-- ``` -->

<!-- **Issue** -->

<!-- - Some variable names are odd, maybe incorrectly read into R: -->
<!-- ```{r, warning=FALSE} -->
<!-- df_avl_byvar %>% select(Data_type) %>% slice(1:9) %>% print() -->
<!-- ``` -->


## 4. Long versus wide

<!-- ### The issue -->

<!-- Let's look at data from just one experiment (`"SwissFACE_trifolium2"`): -->
<!-- ```{r, warning=FALSE} -->
<!-- df_co2 %>% filter(exp_nam == "SwissFACE_lolium2") %>% print() -->
<!-- ``` -->

<!-- This data frame now has multiple rows, corresponding to different sampling dates. Some points here: -->

<!-- - The row Sampling_date is not very clean and cannot coerced into a date object (preferrable to be done with the R package lubridate). This is (almost) ok for now (we're just treating this as replicates, disregarding the information of the date), but needs to be addressed when using the data for model-data fusion (need to "sample" the model output at the same date). However ... -->
<!-- - ... if we are to use 'experiment year since the start' as a factor in our analysis, this needs to be addressed. Either, we try to get the actual sampling date as a lubridate-ymd object (looks like "YY-MM-DD"), and have separate experiment meta information where the start year of the experiment is specified. Or, we just have a row in this data frame here, that specifies the experiment year (year=1 is the first year under treatment, year=0 is the last year of the pre-treatment period, or similar). -->
<!-- - Units are $\mu$ mol? The respective character is not interpreted correctly. This is ok for now, as we are only looking only at response ratios. -->
<!-- - In this example (site `"SwissFACE_trifolium2"`), I am confused about the information given in column `factors` (is `"cf"` for all rows displayed above). I interpret this as saying that this particular experiment was a 2-factorial experiment with a CO2 and fertilization treatment. However, the rows displayed here are only for the CO2-only treatment. Where are the remaining rows? -->
<!-- - **Fundamental question:** In a multi-factorial experiment (let's stick with the example of `"SwissFACE_trifolium2"`), where one factor is CO2, and when trying to quantify the *CO2 effect*, we should use data both from the CO2-only and from the CO2xFertilization treatment and quantify *two* response ratios as c/control and cf/f. Do you agree? The way the data is structured now, it's not straight-forward to get these two response ratios as rows for the *cf* treatment use elevated as *cf*, and ambient as control, not *f*. Hence, the data first needs to be reshaped a bit... Probably best by converting it first to a long format. But let's solve the other points first. -->

### An example conversion

How to perform a conversion of our current wide format to a long format? Let's do it for one example. An example for how the wide format is implemented in the current dataset:
```{r}
df_wide <- df %>% 
  filter(exp_nam=="SwissFACE_lolium2", Data_type=="aboveground_biomass") %>%
  select(exp_nam, factors, treatment, Data_type) %>% 
  distinct() %>%
  mutate( id=1:nrow(.),
          ambient=rep("A", 3), elevated=c("B", "C", "D"),
          ambient_Sd=rep("sdA", 3), elevated_Sd=c("sdB", "sdC", "sdD"),
          ambient_Se=rep("seA", 3), elevated_Se=c("seB", "seC", "seD")) %>%
  print()
```

To convert this to a long format, first get all available factors and create a vector. The available factors are:
```{r}
df %>% 
  filter(!(factors %in% c("x","x99"))) %>% 
  select(factors) %>% 
  unique() %>% 
  unlist() %>% 
  unname() %>% 
  print()
```

Create a vector with all single factors
```{r}
factors_avl <- df %>%
  filter(!(factors %in% c("x","x99"))) %>%      # Something weird with this
  select(factors) %>% 
  unique() %>% 
  mutate( factors_sep = strsplit(factors, NULL) ) %>% 
  select(factors_sep) %>% 
  unlist() %>% 
  unname() %>% 
  unique() %>% 
  print()
```

Convert from wide to long, adding columns for all factors for which we have ambient and elevated levels' data.
```{r warning=FALSE}
wide_to_long_gcme <- function( df_wide, keyvars ){
  
  require(stringr)
  
  ## if level is 'elevated', turn all factor levels that are part of 'treatment' to TRUE
  switch_factor <- function(df){
    if (df$level=="elevated"){
      for (ifactor in strsplit(df$treatment, NULL) %>% unlist()){
        df[[ifactor]] <- TRUE
      }
    }
    return(df)
  }
  
  ## First get available factors
  factors_avl <- df_wide %>%
    filter(!(factors %in% c("x","x99"))) %>%      # Something weird with this
    select(factors) %>% 
    unique() %>% 
    mutate( factors_sep = strsplit(factors, NULL) ) %>% 
    select(factors_sep) %>% 
    unlist() %>% 
    unname() %>% 
    unique()  
  
  df_long <- df_wide %>%
    
    ## gather 'mean' based on columns: 'ambient', 'elevated'
    select( -ambient_Sd, -elevated_Sd, -ambient_Se, -elevated_Se ) %>%
    tidyr::gather(level, mean, c(ambient, elevated)) %>%
    
    ## gather 'sd' based on columns: 'ambient_Sd', 'elevated_Sd'
    left_join( 
      select( df_wide, -ambient, -elevated, -ambient_Se, -elevated_Se ) %>%
        tidyr::gather(level, sd, c(ambient_Sd, elevated_Sd)) %>%
        mutate( level = stringr::str_split(.$level, "_") %>% purrr::map(., 1) %>% unlist() ),
      by = c(keyvars) ) %>% 
    
    ## gather 'se' based on columns: 'ambient_Se', 'elevated_Se'
    left_join( 
      select( df_wide, -ambient, -elevated, -ambient_Sd, -elevated_Sd ) %>%
        tidyr::gather(level, se, c(ambient_Se, elevated_Se)) %>%
        mutate( level = stringr::str_split(.$level, "_") %>% purrr::map(., 1) %>% unlist() ),
      by = c(keyvars) ) %>% 
    
    ## magically add columns corresponding to all available levels of 'factors'
    `is.na<-`(factors_avl) %>% 
    
    ## fill all new factor columns with FALSE
    dplyr::mutate_at( factors_avl, ~FALSE ) 
  
  ## Determine new factor columns based on information in 'treatment' and 'level'
  df_long <- purrr::map_dfr(as.list(1:nrow(df_long)), ~switch_factor(df_long[.,]))
  
  ## Now we have duplicate ambients, treat them separately and stack ambient and elevated together again
  df_long <- df_long %>% filter(level=="ambient") %>% 
    
    # WARNING: This assumes that if values are identical, they are repetitions, ignoring differences w.r.t Sampling_Date
    distinct( exp_nam, factors, Data_type, Unit, Year, mean, sd, se, .keep_all=TRUE ) %>%
    
    # bind them together again. also cleaning replicated rows (note treatment added as column!)
    bind_rows( ., 
               filter(df_long, level=="elevated") %>% 
                 distinct( exp_nam, factors, treatment, Data_type, Unit, Year, mean, sd, se, .keep_all=TRUE )
                 ) %>% 
    
    ## abandon columns, now obsolete with boolean columns for factors 
    select(-treatment, -level, -id)
  
  return(df_long)
}

# run it
keyvars <- c("id", "exp_nam", "factors", "level", "treatment", "Data_type")
valuevars <-  c("ambient", "ambient_Se", "ambient_Sd", "elevated", "elevated_Se", "elevated_Sd")

df_long_example <- df_wide %>%
  select(one_of(keyvars, valuevars)) %>%
  wide_to_long_gcme( keyvars ) %>%
  print()
```


### Converting the entire table

Let's apply this to the full data frame. First, keep only some of the columns:
```{r warning=FALSE, eval=FALSE}
keyvars <- c("id", "exp_nam", "factors", "treatment", "level", "Data_type", "Unit", "Start_Year", "Year",  "n_plots")
valuevars <-  c("ambient", "ambient_Se", "ambient_Sd", "elevated", "elevated_Se", "elevated_Sd")

df_long <- df %>% 
  select(one_of(keyvars, valuevars)) %>%
  # filter(exp_nam=="BioCON" & Data_type=="leaf_N" & Year==4) %>%  # xxx debug
  wide_to_long_gcme(keyvars) %>% 
  write_csv(path="~/data/gcme/data_received_190325/NewData_LONG.csv")
```

Thus, we have a long-format data table, that has *less* than twice as many rows as the original table, because the "absolute ambient" is no longer repeated:
```{r eval=FALSE}
print(nrow(df)*2)
nrow(df_long)
```


#### Test

Test, whether the conversion was doing alright.
```{r}
check_cf <- function(df_wide, df_long, verbose=FALSE){

  ## check cf experiments
  df_cf <- df_wide %>% filter(treatment %in% c("f","c","cf","fc"))

  out <- tibble()

  all_exp <- df_cf$exp_nam %>% unique

  for (iexp in all_exp){

    df_sub <- df_cf %>% filter(exp_nam==iexp)

    all_var <- df_sub$Data_type %>% unique

    for (ivar in all_var){

      df_subsub <- df_sub %>% filter(Data_type==ivar)

      all_var_unit <- df_subsub$Unit %>% unique

      for (iunit in all_var_unit){

        df_subsubsub <- df_subsub %>% filter(Unit==iunit)

        # elevated-f treatment
        correct_f <- df_subsubsub %>% 
          filter(treatment=="f") %>% 
          select(exp_nam, Data_type, Unit, Year, mean=elevated, se=elevated_Se, sd=elevated_Sd) %>%
          all_equal( ., df_long %>% filter(f & !c & exp_nam==iexp & Data_type==ivar & Unit==iunit) %>% select(exp_nam, Data_type, Unit, Year, mean, se, sd) )

        # elevated-c treatment
        correct_c <- df_subsubsub %>% 
          filter(treatment=="c") %>% 
          select(exp_nam, Data_type, Unit, Year, mean=elevated, se=elevated_Se, sd=elevated_Sd) %>%
          all_equal( ., df_long %>% filter(!f & c & exp_nam==iexp & Data_type==ivar & Unit==iunit) %>% select(exp_nam, Data_type, Unit, Year, mean, se, sd) )

        # elevated-cf treatment
        correct_cf <- df_subsubsub %>% 
          filter(treatment=="cf") %>% 
          select(exp_nam, Data_type, Unit, Year, mean=elevated, se=elevated_Se, sd=elevated_Sd) %>%
          all_equal( ., df_long %>% filter(f & c & exp_nam==iexp & Data_type==ivar & Unit==iunit) %>% select(exp_nam, Data_type, Unit, Year, mean, se, sd) )

        # (absolute) control: WARNING: DUPLICATED ROWS
        correct_0 <- df_subsubsub %>% 
          distinct(exp_nam, Data_type, Unit, Year, ambient, ambient_Se, ambient_Sd, .keep_all=TRUE) %>% 
          select(exp_nam, Data_type, Unit, Year, mean=ambient, se=ambient_Se, sd=ambient_Sd) %>%
          all_equal( ., df_long %>% filter(!f & !c & exp_nam==iexp & Data_type==ivar & Unit==iunit) %>% select(exp_nam, Data_type, Unit, Year, mean, se, sd) )
        
        if (verbose){
        if (!identical(correct_0, TRUE)){
          rlang::warn(correct_0)
          print("WIDE:")
          df_subsubsub %>%
            distinct(exp_nam, Data_type, Unit, Year, ambient, ambient_Se, ambient_Sd, .keep_all=TRUE) %>%
            select(exp_nam, Data_type, Unit, Year, mean=ambient, se=ambient_Se, sd=ambient_Sd) %>%
            print()
          print("LONG:")
          df_long %>%
            filter(!f & !c & exp_nam==iexp & Data_type==ivar & Unit==iunit) %>%
            select(exp_nam, Data_type, Unit, Year, mean, se, sd) %>%
            print()
          print("---------")
        }
        }

        out <- bind_rows(out, c(factors="cf", exp_nam=iexp, Data_type=ivar, Unit=iunit, correct_0=correct_0, correct_c=correct_c, correct_f=correct_f, correct_cf=correct_cf))

      }
    }
  }

  return(out)
}
#out <- check_cf( df, df_long) %>% head()
```

**Issue:**

- There are still lots of problems with identifying the ambients (see column `correct_0` in `out`). See for example:

```{r eval=FALSE}
## note row 18 is missing in wide
out <- check_cf( filter(df, exp_nam=="BioCON", Data_type=="leaf_N", Year==4), df_long, verbose = TRUE)
```

**TODO:**

- Make sure the wide-to-long conversion works fine. That is, `out` should have `TRUE` in all columns. 


### Converting back with a twist

In the original data, `ambient` was the "absolute ambient". For example in the `cf` treatment, `ambient` was no treatment at all (control), and `elevated` was `c` $\times$ `f`. We may re-design a wide version of the table and allow flexibility in what treatments are compared to each other, i.e., what `ambient` means. I would argue that this depends whether we are interested in a *single* effect or in interactions. In our case, we are interested primarily in the CO2 effect. Hence, in a factorial experiment `cf`, we may want to compare `c` to `0` (an "absolute ambient"), and `cf` to `f` and thus have more data available to evaluate the CO2-only effect.

Let's implement this, by converting our example back to a CO2-wide format:
```{r}
long_to_wide_gcme <- function(df_long, keyvar){

  joinvars <- names(df_long)[-which(names(df_long) %in% c("mean", "sd", "se", keyvar))]
  factors_all <- df_long %>%
    filter(!(factors %in% c("x","x99"))) %>%      # Something weird with this
    select(factors) %>% 
    unique() %>% 
    mutate( factors_sep = strsplit(factors, NULL) ) %>% 
    select(factors_sep) %>% 
    unlist() %>% 
    unname() %>% 
    unique()
  factorvars <- factors_all[-which(factors_all==keyvar)]
    
  # take all data where factor 'c' is TRUE
  df_wide <- dplyr::filter(df_long, eval(parse(text=keyvar)) ) %>% 
    
    # call this 'elevated'
    dplyr::rename(elevated=mean, elevated_sd=sd, elevated_se=se) %>% 
    
    # remove column 'c', is no longer used
    dplyr::select(-keyvar) %>% 
    
    # merge this with the corresponding row where all other factors are the same, while 'c' is FALSE
    left_join( 
      
      # take all data where factor 'c' is FALSE
      dplyr::filter(df_long, !(eval(parse(text=keyvar)))) %>% 

        # call this 'ambient'
        dplyr::rename(ambient=mean, ambient_sd=sd, ambient_se=se) %>% 

        # remove column 'c', is no longer used
        dplyr::select(-keyvar),
      
      ## merge by all other columns
      by = joinvars ) %>% 
    
    # order columns
    select( c(joinvars, ambient, elevated, ambient_se, elevated_se, ambient_sd, elevated_sd)  )

  return(df_wide)
}
```

Run it
```{r}
df_long_example %>%
  long_to_wide_gcme("c") %>%
  print()
```

The same can be done w.r.t. the fertilisation treatment, with two rows corresponding now to whether or not CO2 was elevated.
```{r}
df_long_example %>%
  long_to_wide_gcme("f") %>%
  print()
```

Let's apply this to the full data frame.
```{r eval=FALSE}
keyvars <- c("ALIAS", "exp_nam", "factors", "Data_type", "Unit", "Sampling_date", "n_plots")
valuevars <-  c("mean", "sd", "se")

df_wide_c <- df_long %>% 
  # select(one_of(keyvars, valuevars, factors_avl)) %>%
  # select(-prev_name, -TT_Nut_Detail) %>% 
  long_to_wide_gcme("c") %>% 
  write_csv(path="~/data/gcme/data_received_190325/NewData_WIDE_c.csv")
```

**TODO:**

- Develop a test to check the new-wide format against the long or against the original-wide table.


<!-- ## 4. Number of replicates -->

<!-- For each variable, get information on the number of replicates available for each experiment (and any other information that is needed for the meta analysis). That's simple now: -->
<!-- ```{r, warning=FALSE} -->
<!-- ## for Asat only -->
<!-- df_nreplicates_asat <- df_co2_asat %>%  -->
<!--   group_by(exp_nam) %>%  -->
<!--   summarise(nreplicates = n()) -->

<!-- ## for all variables, creates a named list -->
<!-- list_nreplicates <- purrr::map( list_co2_byvar, ~group_by(., exp_nam, treatment) %>%  -->
<!--   summarise(nrep = n()) ) %>%  -->
<!--   setNames(varlist) -->
<!-- ``` -->


# Data selection

The initial draft of the figures we want to draw looks like this:

![](./fig/cn_feedback_cascade_draft.jpg)

The following is a list of variables we need according to this draft, and the corresponding (possibly) relevant variables (`Data_type`) in our dataset.

Add two columns to the data. One for the new standard variable name (`varnam`), taken from CSV files. And one for this specific study where multiple variables (based on `varnames`) are pooled because they contain relevant and comparable information when evaluating response ratios (named `my_varnam`).


## ANPP

ANPP: `my_varnam = my_anpp`, and `varnam %in% c("anpp", "anpp_bm")`.

Collect information about experiments providing data for any of `varnam %in% c("anpp", "anpp_bm")`. See procedure [here](https://docs.google.com/document/d/11ghws59q6Ts6j6GK6yNqQBvilrNojRN_aC7c41-LrI0/edit?usp=sharing). Add additional information from the experiments table (`table_var_exp_names_experiments.csv`) and from the data frame `df_experiments`, which is used to associate new and old experiments names.
```{r, warning=FALSE}
df_anpp <- read_csv("~/data/gcme/data_received_190325/table_var_exp_names_anpp.csv") %>% 
  select(prev_name=expnam, varnam, Data_type, Source_Reference) %>%
  distinct() %>% 
  filter(varnam %in% c("anpp", "anpp_bm")) %>% 
  
  ## add 'exp_nam' (new experiment name) from data table
  left_join( df_experiments, by="prev_name" ) %>% 
  
  ## add experiments meta information from experiments table
  left_join( 
    read_csv("~/data/gcme/data_received_190325/table_var_exp_names_experiments.csv") %>% 
      select(prev_name, Fumigation_type, Cquantity_Control, Cquantity_Treatment, Vegetation_type, Plants_specs, Start_Year, End_Year, Remarks),
    by = c("prev_name")
    )
```

Add `my_varnam` to the data table, defined by `my_varnam = ifelse( varnam %in% c("anpp", "anpp_bm"), "my_anpp", my_varnam )`. WARNING: This assumes that variable names 'Data_type' are identical in old and new dataset (manually replaced white spaces with underscores in table_var_exp_names_anpp.csv, first)
```{r, warning=FALSE}
df <- df %>% 
  mutate( varnam=NA ) %>% 
  left_join( select( df_anpp, -prev_name ), by=c("exp_nam", "Data_type") ) %>% 
  distinct(id, .keep_all=TRUE) %>% 
  rename( varnam = varnam.x ) %>% 
  rowwise() %>% 
  mutate( varnam = ifelse(!is.na(varnam.y), varnam.y, varnam ) ) %>% 
  select( -varnam.y ) %>% 
  mutate( my_varnam = NA ) %>% 
  mutate( my_varnam = ifelse( varnam %in% c("anpp", "anpp_bm"), "my_anpp", my_varnam ) )
```

Test analysis and plot of ANPP data. Calculate the response ratio of ANPP (mean and variance) for each experiment. To get that, we first need to calcuate the means and standard deviation for the ambient and elevated levels, pooling multiple measurements (years, sampling dates), each given with mean $\mu_i$, number $N_i$ (replicates/plots), and standard deviation $\sigma_i$ or standard error. For the function `metafor::escalc()`, we need standard deviations ($SD$). Calculate them for those rows where only standard errors $SE$ are given as:
$$
SD = SE \sqrt{N}
$$
Then, the pooled means are:
$$
\mu = \frac{ \sum_i N_i \mu_i }{\sum_i N_i}
$$
and standard deviations:
$$
\sigma = \sqrt{ \frac{\sum_i (N_i-1)\sigma_i^2}{\sum_i (N_i-1)} }
$$

**QUESTION TO CESAR:**

- Is there no component in $\sigma$ that accounts for the variance between the sample means?

Now, do the meta-analysis and plot results.
```{r, warning=FALSE}
library(metafor)   # see ?dat.curtis1998 for an example with CO2 manipulation data
mean_pooled <- function( x, n ){
  sum(x * n)/sum(n)
}
sd_pooled <- function( sd, n ){
  sqrt( sum( (n-1)*sd^2 ) / sum(n-1) )
}

## aggregate by variable and experiment, pooling multiple years, sampling dates, and plots/replicates and calculate log response ratio
df_c_anpp_agg <- df %>%                                         
  filter(treatment=="c") %>%   # filter experiments with only manipulated CO2 (no other factors manipulated, strong reduction of data)
  filter(my_varnam=="my_anpp") %>% 
  mutate( my_ambient_sd = ambient_Sd, my_elevated_sd = elevated_Sd ) %>%   # get standard deviation for all data
  rowwise() %>% 
  mutate( my_ambient_sd   = ifelse( is.na(my_ambient_sd),  ambient_Se  * sqrt(n_plots), my_ambient_sd ),
          my_elevated_sd  = ifelse( is.na(my_elevated_sd), elevated_Se * sqrt(n_plots), my_elevated_sd )) %>%

  ## pool all measurements (multiple years, sampling dates and plots) by variable and experiment for meta analysis
  group_by( exp_nam, treatment, my_varnam ) %>%                        # prepare for aggregation
  summarise( ambient     = mean_pooled( ambient, n_plots ), 
             elevated    = mean_pooled( elevated, n_plots ),
             ambient_sd  = sd_pooled( my_ambient_sd, n_plots ),
             elevated_sd = sd_pooled( my_elevated_sd, n_plots ),
             n_plots = sum(n_plots) ) %>% 

  ## Get logarithm of response ratio and its variance
  metafor::escalc( 
    measure = "ROM", 
    m1i = elevated, sd1i = elevated_sd, n1i = n_plots, 
    m2i = ambient,  sd2i = ambient_sd,  n2i = n_plots, 
    data=., 
    append = TRUE, var.names = c("logr", "logr_var") ) %>% 
  as_tibble() %>% 
  mutate( logr_se = sqrt(logr_var)/sqrt(n_plots) )

## aggregate by variable, doing a meta-analysis of the log response ratios, with experiment as random factor (method="DL")
agg_meta <- function(df, groupvar){
  out_meta <- df %>% dplyr::filter(my_varnam==eval(parse_character(groupvar))) %>% 
    metafor::rma( logr, logr_var, method = "DL", data = . )
  
  # transform back
  out_meta_scaled <- predict( out_meta, transf=exp )
  
  tibble(
    my_varnam=groupvar, 
    middle = out_meta$b[1,1], 
    ymin   = out_meta$ci.lb, 
    ymax   = out_meta$ci.ub,
    
    middle_scaled = out_meta_scaled$pred, 
    ymin_scaled   = out_meta_scaled$ci.lb, 
    ymax_scaled   = out_meta_scaled$ci.ub
  )
}

# do meta-analysis all variables
df_meta <- purrr::map_dfr(as.list(unique(df_c_anpp_agg$my_varnam)), ~agg_meta(df_c_anpp_agg, .))

# Plot
library(ggplot2)
df_c_anpp_agg %>%
  ggplot( aes(x=my_varnam, y=logr)) +
  geom_jitter( color = rgb(0,0,0,0.3), aes( size = 1/logr_se ), position = position_jitter(w = 0.2, h = 0) ) +
  geom_crossbar( data = df_meta, aes(x=my_varnam, y=middle, ymin=ymin, ymax=ymax), fill = "grey80", alpha = 0.6, width = 0.5 ) +
  coord_flip() +
  ylim(-1,1)
```

This shows the log-response ratio of ANPP, each dot for one experiment, multiple years, sampling dates, and plots pooled. The size of the dots represents the standard error of the response ratio (the smaller, the bigger). The box represents the meta-analysis mean and confidence interval of the log response ratio.


And some information about the data used for `my_anpp` (only top 5 rows of a total of 110 available rows, full table at the bottom of this document)
```{r}
df_anpp %>% select(-prev_name, -Cquantity_Control) %>% distinct(varnam, Data_type, exp_nam, .keep_all=TRUE) %>% slice(1:5) %>% knitr::kable()
```


**Issue:**

- There are un-interpretable characters in files, concerning (most problematically) the experiments names. The problem is now, that these are in all data that is read in from multiple CSVs. Changing this by hand has to make sure that they are changed the same way in multiple files.
- Some old experiment names could not be associated with new experiments name because the old names given in the Excel table (sent 25.2.19) are not detected in the new data table (sent 25.3.19). This old-new name association is based on the columns `exp_nam` and `prev_name` in the new data table. For the following old experiment names, no new names could be found:
```{r}
df_anpp %>% filter(is.na(exp_nam)) %>% select(prev_name) %>% distinct() %>% unlist() %>% unname() %>% print()
```
- The CO2 treatment levels are quite diverse. We should normalise the response ratio to that. How?


## Leaf N 

This analysis is done by mass, area, and C:N separately.

- `my_varnam = my_nmass_leaf`, and `varnam == "nmass_leaf"`.
- `my_varnam = my_narea_leaf`, and `varnam == "narea_leaf"`.
- `my_varnam = my_rcton_leaf`, and `varnam == "rcton_leaf"`.

Collect information about experiments providing data for any of `varnam %in% c("anpp", "anpp_bm")`. See procedure [here](https://docs.google.com/document/d/11ghws59q6Ts6j6GK6yNqQBvilrNojRN_aC7c41-LrI0/edit?usp=sharing). Add additional information from the experiments table (`table_var_exp_names_experiments.csv`) and from the data frame `df_experiments`, which is used to associate new and old experiments names.
```{r, warning=FALSE}
df_leafn <- read_csv("~/data/gcme/data_received_190325/table_var_exp_names_leafn.csv") %>% 
  select(prev_name=expnam, varnam, Data_type, Source_Reference) %>%
  distinct() %>% 
  filter(varnam == "nmass_leaf") %>% 
  
  ## add 'exp_nam' (new experiment name) from data table
  left_join( df_experiments, by="prev_name" ) %>% 
  
  ## add experiments meta information from experiments table
  left_join( 
    read_csv("~/data/gcme/data_received_190325/table_var_exp_names_experiments.csv") %>% 
      select(prev_name, Fumigation_type, Cquantity_Control, Cquantity_Treatment, Vegetation_type, Plants_specs, Start_Year, End_Year, Remarks),
    by = c("prev_name")
    )
```

Add `my_varnam` to the data table, defined by `my_varnam = ifelse( varnam == "nmass_leaf", "my_nmass_leaf", my_varnam )`.
```{r, warning=FALSE}
df_right <- select( df_leafn, exp_nam, Data_type, varnam_unified=varnam )
df <- df %>% 
  left_join( select( df_leafn, exp_nam, Data_type, varnam_unified=varnam ), by=c("exp_nam", "Data_type") ) %>% 
  mutate( varnam = ifelse( is.na(varnam), varnam_unified, varnam ) ) %>% 
  mutate( my_varnam = ifelse( varnam == "nmass_leaf", "my_nmass_leaf", my_varnam ) ) %>% 
  select(-varnam_unified)
```

Now, do the meta-analysis and plot results.
```{r, warning=FALSE}
## aggregate by variable and experiment, pooling multiple years, sampling dates, and plots/replicates and calculate log response ratio
df_c_leafn_agg <- df %>%                                         
  filter(treatment=="c") %>%   # filter experiments with only manipulated CO2 (no other factors manipulated, strong reduction of data)
  filter(my_varnam=="my_nmass_leaf") %>% 
  mutate( my_ambient_sd = ambient_Sd, my_elevated_sd = elevated_Sd ) %>%   # get standard deviation for all data
  rowwise() %>% 
  mutate( my_ambient_sd   = ifelse( is.na(my_ambient_sd),  ambient_Se  * sqrt(n_plots), my_ambient_sd ),
          my_elevated_sd  = ifelse( is.na(my_elevated_sd), elevated_Se * sqrt(n_plots), my_elevated_sd )) %>%

  ## pool all measurements (multiple years, sampling dates and plots) by variable and experiment for meta analysis
  group_by( exp_nam, treatment, my_varnam ) %>%                        # prepare for aggregation
  summarise( ambient     = mean_pooled( ambient, n_plots ), 
             elevated    = mean_pooled( elevated, n_plots ),
             ambient_sd  = sd_pooled( my_ambient_sd, n_plots ),
             elevated_sd = sd_pooled( my_elevated_sd, n_plots ),
             n_plots = sum(n_plots) ) %>% 

  ## Get logarithm of response ratio and its variance
  metafor::escalc( 
    measure = "ROM", 
    m1i = elevated, sd1i = elevated_sd, n1i = n_plots, 
    m2i = ambient,  sd2i = ambient_sd,  n2i = n_plots, 
    data=., 
    append = TRUE, var.names = c("logr", "logr_var") ) %>% 
  as_tibble() %>% 
  mutate( logr_se = sqrt(logr_var)/sqrt(n_plots) )

## aggregate by variable, doing a meta-analysis of the log response ratios, with experiment as random factor (method="DL")
agg_meta <- function(df, groupvar){
  out_meta <- df %>% dplyr::filter(my_varnam==eval(parse_character(groupvar))) %>% 
    metafor::rma( logr, logr_var, method = "DL", data = . )
  
  # transform back
  out_meta_scaled <- predict( out_meta, transf=exp )
  
  tibble(
    my_varnam=groupvar, 
    middle = out_meta$b[1,1], 
    ymin   = out_meta$ci.lb, 
    ymax   = out_meta$ci.ub,
    
    middle_scaled = out_meta_scaled$pred, 
    ymin_scaled   = out_meta_scaled$ci.lb, 
    ymax_scaled   = out_meta_scaled$ci.ub
  )
}

# do meta-analysis all variables
df_meta <- purrr::map_dfr(as.list(unique(df_c_leafn_agg$my_varnam)), ~agg_meta(df_c_leafn_agg, .))

# Plot
library(ggplot2)
df_c_leafn_agg %>%
  ggplot( aes(x=my_varnam, y=logr)) +
  geom_jitter( color = rgb(0,0,0,0.3), aes( size = 1/logr_se ), position = position_jitter(w = 0.2, h = 0) ) +
  geom_crossbar( data = df_meta, aes(x=my_varnam, y=middle, ymin=ymin, ymax=ymax), fill = "grey80", alpha = 0.6, width = 0.5 ) +
  coord_flip() +
  ylim(-1,1)
```


<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("ANPP", "annual_aboveground_biomass_production", "aboveground_production", "annual_aboveground_biomass_production", "aboveground_biomass_production"), "my_anpp", my_var ) ) -->

<!-- ## NEW: -->
<!-- df_wide_c <- df_wide_c %>%  -->
<!--   mutate( my_var = ifelse( Data_type=="ANPP" & exp_nam=="BioCON", "my_anpp", my_var ) ) %>%  -->
<!--   mutate( my_var = ifelse( Data_type=="ANPP" & exp_nam=="asdf",   "my_anpp", my_var ) ) %>%  -->

<!-- ``` -->

<!-- - N uptake: `N_uptake`, `NH4+_uptake` (**OK here?**),  -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("N_uptake", "NH4+_uptake"), "my_nup", my_var ) ) -->
<!-- ``` -->

<!-- - N availability: `nmin_mass`, `nh4_mass`, `no3_mass`, `nmin_solution`, `nh4_solution`, `no3_solution`, `nmin_resin`, `nh4_resin`, `no3_resin` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("soil_NO3-", "soil_NH4+", "soil_NH4-N", "soil_mineral_N", "mineral_soil_N", "resin_NH4+", "resin_NO3-"), "my_navl", my_var ) ) -->
<!-- ``` -->

<!-- - N fixation: `number_of_nodes` **Only this data available?** -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("number_of_nodes"), "my_nfix", my_var ) ) -->
<!-- ``` -->

<!-- - Belowground C allocation: `root_biomass`, `root_biomass_(>2mm)`, `root_C`, `root_growth`, `root_mass`, `belowground_biomass`, `belowground_biomass_C`, `belowground_C`, `coarse_root_biomass` (**OK here?**), `fine_root_biomass`, `fine_root_production`, `BNPP`, `root_biomass_input` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("root_biomass", "root_biomass_(>2mm)", "root_C", "root_growth", "root_mass", "belowground_biomass", "belowground_biomass_C", "belowground_C", "coarse_root_biomass", "fine_root_biomass", "fine_root_production", "BNPP", "root_biomass_input"), "my_croot", my_var ) ) -->
<!-- ``` -->

<!-- - Root:shoot ratio: `root-shoot_ratio`, `R/S` (**Is that what it means?**) -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("root-shoot_ratio", "R/S"), "my_rootshoot", my_var ) ) -->
<!-- ``` -->

<!-- - SOM decomposition: `litter_decomposition` (**OK only if it's a relative rate**), `net_C_mineralization`, `aboveground_litter_C_mineralization`, `belowground_litter_C_mineralization` (**Is this all we have?**) -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("litter_decomposition", "net_C_mineralization", "aboveground_litter_C_mineralization", "belowground_litter_C_mineralization"), "my_decomp", my_var ) ) -->
<!-- ``` -->


<!-- - Net N mineralization: `potential_net_N_mineralization`, `net_N_mineralization`, `soil_N_mineralization` (**Check whether this is net or gross**) -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("potential_net_N_mineralization", "net_N_mineralization", "soil_N_mineralization"), "my_nmin", my_var ) ) -->
<!-- ``` -->


<!-- - N losses: `soil_N2O_efflux`, `soil_N_efflux`, `15N_recovery` (**Look into this**), `N_leaching`, `NO3-_leaching` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("soil_N2O_efflux", "soil_N_efflux", "N_leaching", "NO3-_leaching"), "my_nloss", my_var ) ) -->
<!-- ``` -->

<!-- - leaf N: `nmass_leaf`, `narea_leaf`, `rcton_leaf`, `nareaground_canopy`, `nareaground_agbm`, `nmass_agbm`, `rcton_agbm` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("leaf_N"), "my_nleaf", my_var ) ) -->
<!-- ``` -->

<!-- - Tissue C:N: `total_biomass_C:N`, `belowground_biomass_C:N`, `leaf_litter_N` (**OK here?**), `fine_root_N` (**OK here?**), `aboveground_biomass_C:N`, `leaf_litter_C:N`, `fine_root_C:N`, `wood_C/N` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("total_biomass_C:N", "belowground_biomass_C:N", "aboveground_biomass_C:N", "leaf_litter_C:N", "fine_root_C:N`", "wood_C/N"), "my_rcton", my_var ) ) -->
<!-- ``` -->

<!-- Potentially interesting as well: -->

<!-- - Resorption: `resorption_efficiency` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("resorption_efficiency"), "my_nresorp", my_var ) ) -->
<!-- ``` -->

<!-- - Biomass: `biomass_C`, `total_biomass` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("biomass_C", "total_biomass"), "my_ctot", my_var ) ) -->
<!-- ``` -->

<!-- - Aboveground biomass: `aboveground_biomass`, `Aboveground_biomass` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("aboveground_biomass", "Aboveground_biomass"), "my_caboveground", my_var ) ) -->
<!-- ``` -->

<!-- - Mycorrhizal stuff: `mycorrhizal_colonization`, `mycorrhizal_root_colonization` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("mycorrhizal_colonization", "mycorrhizal_root_colonization"), "my_myc", my_var ) ) -->
<!-- ``` -->

<!-- - Exudation: `DOC_exudation`, `exudation`, `Exudation` -->

<!-- ```{r, warning=FALSE} -->
<!-- df_wide_c <- df_wide_c %>% mutate( my_var = ifelse( Data_type %in% c("DOC_exudation", "exudation", "Exudation"), "my_cexu", my_var ) ) -->
<!-- ``` -->


<!-- # Data analysis -->

<!-- ## With old format -->

<!-- As a first analysis, for all the experiments with manipulated CO2, we calculate the mean log-response ratio (`logr`) and the number of data points (`n_plots`), aggregated by variable (`Data_type`), experiment (`exp_nam`) and treatment (`treatment`). -->

<!-- ```{r, warning=FALSE} -->
<!-- library(metafor)   # see ?dat.curtis1998 for an example with CO2 manipulation data -->
<!-- df_c <- df %>%                                          -->
<!--   filter(treatment=="c") %>%   # filter experiments with only manipulated CO2 (no other factors manipulated, strong reduction of data) -->
<!--   mutate( my_ambient_sd = ambient_Sd, my_elevated_sd = elevated_Sd ) %>%   # get standard deviation for all data -->
<!--   rowwise() %>%  -->
<!--   mutate( my_ambient_sd   = ifelse( is.na(my_ambient_sd),  ambient_Se  * sqrt(n_plots), my_ambient_sd ), -->
<!--           my_elevated_sd  = ifelse( is.na(my_elevated_sd), elevated_Se * sqrt(n_plots), my_elevated_sd )) %>% -->
<!--   metafor::escalc(  -->
<!--     measure = "ROM",  -->
<!--     m1i = elevated, sd1i = my_elevated_sd, n1i = n_plots,  -->
<!--     m2i = ambient,  sd2i = my_ambient_sd,  n2i = n_plots,  -->
<!--     data=.,  -->
<!--     append = TRUE, var.names = c("logr", "logr_sd") ) -->

<!--   mutate( logr = log(elevated/ambient) ) %>%              # calculate log response ratio -->
<!--   group_by( exp_nam, my_var, treatment ) %>%              # prepare for aggregation -->
<!--   summarise( logr = mean(logr, na.rm=TRUE), n_plots = sum(n_plots) )   # This is a dumb mean, not taking into account the standard error and N. Warning also for na.rm = TRUE. -->
<!-- ``` -->

<!-- **Issue:** -->

<!-- - Is number of plots (`n_plots`) always identical for ambient and elevated? It's not distinguished in the dataset. -->


<!-- ## With new format -->

<!-- **TODO:** -->

<!-- - Do this aggregation once the wide-to-long and long-to-wide steps are working correctly (see tests above). Then the following can be executed: -->

<!-- As a first analysis, for all the experiments with manipulated CO2, we calculate the mean log-response ratio (`logr`) and the number of data points (`n_plots`), aggregated by variable (`Data_type`), experiment (`exp_nam`) and treatment (`treatment`). -->


<!-- ```{r, warning=FALSE, eval=FALSE} -->
<!-- df_meta <- df_wide_c %>%                                             # only experiments with manipulated CO2 -->
<!--   mutate( my_ambient_sd = ambient_sd, my_elevated_sd = elevated_sd ) %>%   # get standard deviation for all data -->
<!--   rowwise() %>%  -->
<!--   mutate( my_ambient_sd   = ifelse( is.na(my_ambient_sd),  ambient_se  * sqrt(n_plots), my_ambient_sd ), -->
<!--           my_elevated_sd  = ifelse( is.na(my_elevated_sd), elevated_se * sqrt(n_plots), my_elevated_sd )) -->

<!--   mutate( my_ambient_sd  = ifelse( is.na(my_ambient_sd),  ambient_se  * sqrt(n_plots), ambient_sd ),        # SD = SE * sqrt(N) -->
<!--           my_elevated_sd = ifelse( is.na(my_elevated_sd), elevated_se * sqrt(n_plots), elevated_sd) ) %>%   # SD = SE * sqrt(N) -->
<!--   mutate( logr = log(elevated/ambient) ) %>%              # calculate log response ratio -->
<!--   group_by( exp_nam, my_var, f ) %>%              # prepare for aggregation -->
<!--   summarise( logr = mean(logr, na.rm=TRUE), n_plots = sum(n_plots) )   # This is a dumb mean, not taking into account the standard error and N. Warning also for na.rm = TRUE. -->
<!-- ``` -->

<!-- ## Plot -->

<!-- Plot all variables. -->
<!-- ```{r, warning=FALSE} -->
<!-- library(ggplot2) -->
<!-- df_meta %>% filter(!is.na(my_var)) %>%  -->
<!--   ggplot( aes(x=my_var, y=logr)) + -->
<!--   geom_jitter( color = rgb(0,0,0,0.3), aes( size = n_plots ), position = position_jitter(w = 0.3, h = 0) ) + -->
<!--   geom_boxplot( outlier.shape=NA, fill = "grey80", alpha = 0.6, width = 0.5 ) + -->
<!--   coord_flip() + -->
<!--   ylim(-2,2) -->
<!-- ``` -->

<!-- # Experiments tables by variable -->

<!-- ## ANPP -->

<!-- ```{r} -->
<!-- df_anpp %>% select(-prev_name, -Cquantity_Control) %>% distinct(varnam, Data_type, exp_nam, .keep_all=TRUE) %>% knitr::kable() -->
<!-- ``` -->

